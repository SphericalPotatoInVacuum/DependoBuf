{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>DependoBuf is a novel structured data serialization format that incorporates dependent types into the data model. It is designed to be a more expressive and safe alternative by providing the ability to describe not only the structure of the data, but the relationships between the data as well and enforcing those relationships at both compile and runtime.</p> Protocol BuffersDependoBuf <p> <pre><code>message TreeH {\n    message TreeHLeaf {\n        int32 value = 1;\n        uint32 height = 2;\n    }\n\n    message TreeHNode {\n        int32 value = 1;\n        uint32 height = 2;\n        TreeH left = 3;\n        TreeH right = 4;\n    }\n\n    oneof treeh_type {\n        TreeHLeaf leaf = 1;\n        TreeHNode node = 2;\n    }\n}\n</code></pre> <p> Constraints not obvious</p> <p> No way to define constraints in schema</p> <p> No way to validate constraints soundness</p> <p> Need to write custom code to validate constraints  </p> <p> <pre><code>enum TreeH (height Unsigned) {\n    0 =&gt; {\n        TreeHLeaf {\n            value Int\n        }\n    }\n    * =&gt; {\n        TreeHNode {\n            value Int\n            left TreeH (height - 1)\n            right TreeH (height - 1)\n        }\n    }\n}\n</code></pre> <p> Obvious constraints</p> <p> Constraint definition in schema</p> <p> Soundness validation at compile time</p> <p> Automatic validation of constraints at runtime  </p> <p>This documentation is meant to be a reference for the language and its features. This documentation is not meant to be an explanation of the internal workings of the compiler or the runtime. They are both works in progress, but you can find the source code project's GitHub.</p> <p>Warning</p> <p>This is a work in progress. The language and its features are subject to change. If you have any suggestions or feedback, please open an issue on GitHub.</p>"},{"location":"enums/","title":"Enums","text":"<p>Enums in DependoBuf resemble those in Rust, as in the enum constructors have fields too. One of the main differences of enums from messages is that enums allow you to define whether a type has a constructor based on the value of the type dependencies. This is done by providing a mapping from the dependency patterns to the constructors.</p> <p>In case of no dependencies, there is no pattern mapping and the enum body contains only the list of constructors.</p> \\[ \\begin{align*} \\mathrm{constructor\\_declarations} ::=&amp;\\ \\lbrace constructor\\_identifier\\ \\lbrack \\texttt{\\{} \\lbrace typed\\_variable \\rbrace \\texttt{\\}} \\rbrack \\rbrace \\\\ input\\_patterns ::=&amp;\\ \\texttt{*} \\mid value \\ \\lbrace\\ \\texttt{,}\\ ( \\texttt{*} \\mid value ) \\rbrace \\\\ mapping\\_rules ::=&amp;\\ input\\_patterns\\ \\texttt{=&gt;}\\ \\texttt{\\{}\\ constructor\\_declarations\\ \\texttt{\\}} \\\\ \\\\ enum\\_definition ::=&amp;\\ independent\\_enum \\mid dependent\\_enum \\\\ independent\\_enum ::=&amp;\\ \\texttt{enum}\\ type\\_identifier\\ \\texttt{\\{}\\ constructor\\_declarations\\ \\texttt{\\}}\\\\ dependent\\_enum ::=&amp;\\ \\texttt{enum}\\ type\\_identifier\\ type\\_dependency \\lbrace type\\_dependency \\rbrace\\ \\texttt{\\{}\\ mapping\\_rules\\ \\texttt{\\}} \\\\ \\end{align*} \\] Example enum definition<pre><code>enum IntList (n Unsigned) {\n  0 =&gt; {\n    Nil\n  }\n  * =&gt; {\n    ListNode {\n      value Int\n      tail  IntList (n - 1)\n    }\n  }\n}\n</code></pre> <p>While messages allow you to use dot notation to access fields, enums allow you to use pattern matching to deconstruct values and get field values that way.</p> Example deconstruction<pre><code>enum Nat {\n  Zero\n  Succ {\n    pred Nat\n  }\n}\n\nenum Foo (n Nat) {\n  Zero =&gt; {}\n  Succ{pred: x} =&gt; {\n    Here `x` is bound to the value of the `pred` field of the `Succ` constructor.\n    You can use `x` on the right of the `=&gt;` to reference the value of the `pred`\n    field.\n  }\n}\n</code></pre>"},{"location":"expressions/","title":"Expressions","text":""},{"location":"expressions/#value-expressions","title":"Value expressions","text":"<p>Value expressions are used to compute values. They can be used wherever a value is expected, for example in field initializations, in pattern matching, or in type parametrization.</p> <p>From this point forward we will omit \"value\" and just say \"expression\", implying that it is a value expression, unless otherwise specified.</p> \\[ \\begin{align*}   expression ::=&amp;   \\ expression   \\left(\\ \\texttt{+} \\mid \\texttt{-} \\mid \\texttt{*} \\mid \\texttt{/} \\mid \\texttt{&amp;} \\mid \\texttt{|}\\ \\right)   expression \\\\   \\mid&amp;\\ \\texttt{-} expression  \\\\   \\mid&amp;\\ \\texttt{!} expression  \\\\   \\mid&amp;\\ primary \\end{align*} \\]"},{"location":"expressions/#precedence-and-associativity","title":"Precedence and Associativity","text":"<p>DependoBuf uses the same precedence and associativity rules as any other language, which are also used in mathematics. The following table lists operators in order of decreasing precedence:</p> Operator Description <code>!</code> Logical NOT <code>-</code> Arithmetic negation <code>*</code> Multiplication <code>/</code> Division <code>&amp;</code> Logical AND <code>+</code> Addition <code>-</code> Subtraction <code>|</code> Logical OR"},{"location":"expressions/#primary-expressions","title":"Primary expressions","text":"<p>Primary is like an atomic expression. It can be a value, a variable (with optional field access), or a parenthesized expression.</p> \\[ \\begin{align*}   var\\_access ::=&amp;\\ var\\_identifier \\lbrace \\ \\texttt{.}\\ var\\_identifier \\rbrace \\\\   primary ::=&amp;\\ value \\mid var\\_access   \\mid \\texttt{(} expression \\texttt{)} \\end{align*} \\]"},{"location":"expressions/#type-expressions","title":"Type expressions","text":"<p>Type expressions are used to compute types. They can be used wherever a type is expected: in declarations of parameters (be it type parameters or rpc parameters), or in field declarations. Such a variable declaration is called a typed variable in our grammar. It is simply a variable identifier followed by a type expression.</p> <p>Type expressions consist of type name and optional type parameters. Type parameters need to be primary expressions to avoid ambiguity.</p> \\[ \\begin{align*}   type\\_expr ::=&amp;\\ type\\_identifier \\lbrace primary \\rbrace \\\\   typed\\_variable ::=&amp;\\ var\\_identifier\\ type\\_expr \\end{align*} \\]"},{"location":"messages/","title":"Messages","text":"<p>One of the two main types in DependoBuf is a message type. Message declaration consists of a keyword <code>message</code>, followed by a type identifier, followed by optional type dependencies, followed by a block of field declarations.</p> \\[ \\begin{align*}   type\\_dependency ::=&amp;\\ \\texttt{(}\\ type\\_variable \\texttt{)}\\\\   message\\_definition ::=&amp;\\ \\texttt{message}\\ type\\_identifier   \\ \\lbrace type\\_dependency \\rbrace\\   \\texttt{\\{}\\ \\lbrace typed\\_variable \\rbrace\\ \\texttt{\\}} \\end{align*} \\] Example message declaration<pre><code>message User (n Unsigned) {\n  name String\n  id Unsigned\n  age Int\n  active Bool\n  friends Vec User n\n}\n</code></pre> <p>Compiler will generate a constructor for each message type with the same name as the message itself. Because a message has only one constructor, you can use dot notation to access fields of a message.</p> Example message usage<pre><code>message Foo {\n  bar Int\n}\n\nmessage Baz (n Int) {}\n\nmessage Quux {\n  foo Foo\n  baz Baz foo.bar\n}\n</code></pre> <p>In this example you also see that you can use an already declared field as a variable in another field declaration.</p> <p>When creating a value of type <code>Quux</code> and initializing its fields you will have to provide such a value for the <code>baz</code> field that its type parameter <code>n</code> matches the <code>bar</code> field of the value you provided for the <code>foo</code> field. But don't worry, as all this will be checked by the compiler and you will get a compile-time error if you try to create a value that doesn't match the expected type.</p>"},{"location":"lexical-structure/","title":"Lexical Structure","text":"<p>This section contains the description of DependoBuf's lexical structure.</p>"},{"location":"lexical-structure/identifiers/","title":"Identifiers","text":""},{"location":"lexical-structure/identifiers/#basic-building-blocks","title":"Basic building blocks","text":"<p>DependoBuf emposes strict rules on the names of identifiers. The following productions are the basic building blocks of DependoBuf's syntax.</p> \\[ \\begin{align*} lc\\_letter &amp;::= \\texttt{a} \\mid \\texttt{b} \\mid \\ldots \\mid \\texttt{z} \\\\ uc\\_letter &amp;::= \\texttt{A} \\mid \\texttt{B} \\mid \\ldots \\mid \\texttt{Z}\\\\ digit &amp;::= \\texttt{0} \\mid \\texttt{1} \\mid \\ldots \\mid \\texttt{9}\\\\ ident\\_char &amp;::= lc\\_letter \\mid uc\\_letter \\mid digit \\end{align*} \\]"},{"location":"lexical-structure/identifiers/#identifier-definitions","title":"Identifier definitions","text":"<p>From these building blocks, we can construct identifiers:</p> \\[ \\begin{align*} lc\\_identifier &amp;::= lc\\_letter \\lbrace ident\\_char \\rbrace \\\\ uc\\_identifier &amp;::= uc\\_letter \\lbrace ident\\_char \\rbrace \\\\ type\\_identifier &amp;::= uc\\_identifier constructor\\_identifier &amp;::= uc\\_identifier var\\_identifier &amp;::= lc\\_identifier \\end{align*} \\] <p>In DependoBuf identifiers are case sensitive. This means that <code>foo</code> and <code>Foo</code> are different identifiers. Moreover, the case of the identifier bears a semantic meaning.</p> <p>Every lowercase identifier is a variable (like a type dependency, which can be understood as a parameter of the type; or a field of a constructed value).</p> <p>Every uppercase identifier is a type (which are defined using <code>message</code> or <code>enum</code> keywords) or a constructor of a type (which are defined inside <code>enum</code> body by the user or implicitly by the compiler for <code>message</code> types).</p>"},{"location":"lexical-structure/keywords/","title":"Keywords","text":"<p>DependoBuf has a number of keywords that are reserved for use by the language itself. You cannot use these keywords as identifiers in your schema.</p> Keyword Description \\(\\texttt{message}\\) Begins a message definition. \\(\\texttt{enum}\\) Begins an enum definition. \\(\\texttt{=&gt;}\\) Maps input patterns to constructors in an enum definition. \\(\\texttt{service}\\) Begins a service definition. Not used at the moment, but reserved for future. \\(\\texttt{rpc}\\) Begins an RPC definition. Not used at the moment, but reserved for future. \\(\\texttt{returns}\\) Separates the request and response types in an RPC definition. Not used at the moment, but reserved for future. \\(\\texttt{true}\\) Boolean literal. \\(\\texttt{false}\\) Boolean literal."},{"location":"lexical-structure/notation/","title":"Notation","text":"<p>Throughout this section we will be using an extended version of the Backus-Naur Form (BNF) to describe the syntax of DependoBuf. The following table describes the symbols used in the notation:</p> Notation Examples Description \\(pat\\) \\(lc\\_letter\\) A non-terminal production. \\(::=\\) \\(a ::= \\texttt{a}\\) Definition. Represents the definition of a non-terminal. \\(\\texttt{literal}\\) \\(\\texttt{message}\\) Terminal syntax. Represents exactly the characters you see. \\(\\mid\\) \\(\\texttt{a} \\mid \\texttt{b}\\) Alternation. Represents a choice between two or more alternatives. \\([pat]\\) \\([lc\\_letter]\\) Optional. Represents zero or one occurrences of the enclosed pattern. \\(\\lbrace pat\\rbrace\\) \\(\\lbrace lc\\_letter\\rbrace\\) Repetition. Represents zero or more occurrences of the enclosed pattern. \\(\\lgroup pat\\rgroup\\) \\(\\lgroup lc\\_letter\\rgroup\\) Grouping. Represents a group of patterns. \\(pat_{\\langle excl \\rangle}\\) \\(lc\\_letter_{\\langle \\texttt{a} \\mid \\texttt{b}\\rangle}\\) Exclusion. Represents the pattern except for the excluded characters. <p>It is important to note the distinction between \\(\\mid\\) and \\(\\texttt{|}\\) and between \\(\\lbrace \\rbrace\\) and \\(\\texttt{\\{} \\texttt{\\}}\\), however it should be clear from the context which one is being used.</p>"},{"location":"lexical-structure/values/","title":"Values","text":"<p>You can use values in your schema to parametrize types, initialize fields, and match patterns. Values can be of two kinds: literals and constructed values.</p> \\[ \\begin{align*} value ::= literal \\mid constructed\\_value \\end{align*} \\]"},{"location":"lexical-structure/values/#literals","title":"Literals","text":"<p>Literals are used to represent concrete values of basic types like integers, floats, strings, and booleans.</p> \\[ \\begin{align*} any &amp;::= \\text{any single character except a newline} \\\\ string\\_literal &amp;::= \\texttt{\"}any_{\\langle\\texttt{\"}\\mid\\texttt{\\\\}\\rangle}\\texttt{\"} \\\\ int\\_literal &amp;::= [\\texttt{+}\\mid\\texttt{-}] digit \\lbrace digit \\rbrace \\\\ unsigned\\_int\\_literal &amp;::= digit \\lbrace digit \\rbrace \\texttt{u} \\\\ float\\_literal &amp;::= [\\texttt{+}\\mid\\texttt{-}] digit \\lbrace digit \\rbrace \\texttt{.} digit \\lbrace digit \\rbrace \\\\ bool\\_literal &amp;::= \\texttt{true} \\mid \\texttt{false} \\\\ literal &amp;::= string\\_literal \\mid int\\_literal \\mid unsigned\\_int\\_literal \\mid float\\_literal \\mid bool\\_literal \\end{align*} \\]"},{"location":"lexical-structure/values/#constructed-values","title":"Constructed Values","text":"<p>Constructed values are used to represent values of complex types like messages and enums. They are created using a type constructor and field initializations. Field initialization must initialize all fields of the type in the order they are declared.</p> <p>Notice that here we use the \\(expression\\) production. It will be defined in the next chapter.</p> \\[ \\begin{align*} constructed\\_value &amp;::= constructor\\_identifier ~\\texttt{\\{}~ field\\_inits ~\\texttt{\\}}~ \\\\ field\\_inits &amp;::= \\lbrace field\\_init \\lbrace ~\\texttt{,}~ field\\_init \\rbrace \\rbrace \\\\ field\\_init &amp;::= var\\_identifier ~\\texttt{:}~ expression \\end{align*} \\]"}]}
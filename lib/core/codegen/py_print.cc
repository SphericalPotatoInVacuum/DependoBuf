#include "core/codegen/py_print.h"

#include <iostream>
#include <memory>
#include <unordered_map>
#include <vector>

namespace dbuf::gen {
const std::unordered_map<std::string, std::string> PyPrinter::kBuildInTypes = {
    {"Int", "int"},
    {"Unsigned", "Unsigned"},
    {"Float", "float"},
    {"String", "str"},
    {"Bool", "bool"},
};

const std::string PyPrinter::kReadme = "# This file was automatically generated by DependoBuf.\n"
                                       "# Please do not change it.\n";

const std::string PyPrinter::kImports = "\n"
                                        "from __future__ import annotations\n"
                                        "\n"
                                        "from annotated_types import Ge\n"
                                        "from dataclasses import dataclass\n"
                                        "from typing import Annotated\n";

const std::string PyPrinter::kCreateUnsigned = "\n"
                                               "Unsigned = Annotated[int, Ge(0)]\n";

PyPrinter::PyPrinter(std::shared_ptr<std::ofstream> output) {
  out_ = std::move(output);

  std::string tab = "    ";
  tabs_.push_back("");
  for (int i = 1; i <= 4; ++i) {
    tabs_.push_back(tabs_[i - 1] + tab);
  }
}

std::string PyPrinter::get_python_type(const std::string &type, bool inside_outer_class) {
  if (kBuildInTypes.contains(type)) {
    return kBuildInTypes.at(type);
  }

  if (inside_outer_class) {
    return "__" + type;
  }

  std::string struct_type = type + "." + camel_to_snake(type) + "_type";
  return struct_type;
}

std::string PyPrinter::camel_to_snake(const std::string &camel_str) {
  std::string snake_str = "";
  for (int i = 0; i < camel_str.size(); ++i) {
    char c = camel_str[i];

    if ('A' <= c && c <= 'Z') {
      c = (char)tolower(c);
      if (i != 0) {
        snake_str += '_';
      }
    }

    snake_str += c;
  }

  return snake_str;
}

std::string PyPrinter::typed_args(std::vector<std::string> &names,
    std::vector<std::string> &types,
    std::string fitst_arg) {
  // self, x: int, y: float
  std::string args = "(" + fitst_arg;
  std::string sep = ", ";

  for (int i = 0; i < names.size(); ++i) {
    std::string py_type = get_python_type(types[i]);
    args += sep + names[i] + ": " + py_type;
  }
  args += ")";
  return args;
}

std::string PyPrinter::untyped_args(std::vector<std::string> &names) {
  // self, x: int, y: float
  std::string args = "(";
  std::string sep = ", ";

  for (int i = 0; i < names.size(); ++i) {
    if (i != 0) {
      args += sep;
    }
    args += names[i];
  }

  args += ")";
  return args;
}

void PyPrinter::print_line(std::vector<std::string> tokens, int level) {
  *out_ << tabs_[level];

  for (auto &token : tokens) {
    *out_ << token;
  }
  *out_ << "\n";
}

void PyPrinter::print_def_with_typed_args(
    std::string name,
    std::string first_arg,
    std::vector<std::string> &arg_names,
    std::vector<std::string> &arg_types,
    int level,
    std::string res_type) {

  std::string args = typed_args(arg_names, arg_types, first_arg);

  std::vector<std::string> tokens = {"def ", name, args, " -> ", res_type, ":"};
  print_line(tokens, level);
}

void PyPrinter::print_instance_method(
    std::string name,
    std::vector<std::string> &arg_names,
    std::vector<std::string> &arg_types,
    int level,
    std::string res_type) {

  print_def_with_typed_args(name, "self", arg_names, arg_types, level, res_type);
}

void PyPrinter::print_class_method(
    std::string name,
    std::vector<std::string> &arg_names,
    std::vector<std::string> &arg_types,
    int level,
    std::string res_type) {

  print_def_with_typed_args(name, "cls", arg_names, arg_types, level, res_type);
}

void PyPrinter::print_constructor(std::string def_name,
      const std::string &struct_name,
      std::vector<std::string> &names,
      std::vector<std::string> &types,
      int level) {

  print_line();

  // def construct(self, x: int, y: float) -> __Address:
  std::string res_type = get_python_type(struct_name, true);
  print_instance_method(def_name, names, types, level, res_type);
  level++;

  // obj = self.__Address(x, y)
  std::string args = untyped_args(names);
  print_line({"obj = self.", res_type, args}, level);

  print_line({"obj.check(*self.dependencies)"}, level);
  print_line({"return obj"}, level);
}

void PyPrinter::init_file() {
  *out_ << kReadme << kImports << kCreateUnsigned;
}

void PyPrinter::print_outer_class(const std::string &name) {
  // class {name}:
  print_line();
  print_line();
  print_line({"class ", name, ":"});
}

void PyPrinter::print_inner_class(const std::string &name, int level) {
  // @dataclass
  // class __{name}:
  print_line({"@dataclass"}, level);
  print_line({"class ", "__", name, ":"}, level);
}

void PyPrinter::print_inner_class_field(const std::string &name, const std::string &type, int level) {
  // "  {name}: {py_type}"
  std::string py_type = get_python_type(type);
  print_line({name, ": ", py_type}, level);
}

void PyPrinter::print_def_check(
    std::vector<std::string> &names,
    std::vector<std::string> &types,
    std::unordered_map<std::string, std::vector<std::string>> &fields_deps,
    const std::string &struct_name,
    int level) {
  print_line();

  // def check(self, x: int, y: float, z: str) -> None:
  print_instance_method("check", names, types, level);
  level++;

  // if type(self) not in SomeMessage.possible_types(x, y, z):
  std::string args = untyped_args(names);
  std::vector<std::string> tokens = {"if type(self) not in ", struct_name, ".possible_types", args, ":"};
  print_line(tokens, level);
  level++;

  std::string raise_exc = "raise TypeError('Non-compliance with type dependencies')";
  print_line({raise_exc}, level);
  level--;
}

void PyPrinter::print_type(const std::string &struct_name, std::vector<std::string> &inner_types, int level) {
  // some_enam_type = __Nil | __Succ
  print_line();

  std::string left = camel_to_snake(struct_name) + "_type";
  std::string right = "__" + inner_types[0];

  std::string sep = " | ";
  for (int i = 1; i < inner_types.size(); ++i) {
    right += sep + "__" + inner_types[i];
  }
  print_line({left, " = ", right}, level);
}

void PyPrinter::print_dep_deps(std::string &dep_name, std::vector<std::string> &deps, int level) {
  // __k_deps = []
  std::vector<std::string> tokens = {"__", dep_name, "_deps = []"};
  print_line(tokens, level);
}

void PyPrinter::print_def_possible_types(
    std::vector<std::string> &names,
    std::vector<std::string> &types,
    int level) {
  // @classmethod
  // def possible_types(cls, x: int, y: float) -> set[type]:
  print_line();
  print_line({"@classmethod"}, level);
  print_class_method("possible_types", names, types, level, "set[type]");
  level++;

  // return {cls.__SomeMessage}
  std::vector<std::string> tokens = {"return {}"};
  print_line(tokens, level);
}

void PyPrinter::print_def_init(
    std::vector<std::string> &names,
    std::vector<std::string> &types,
    int level) {

  print_line();

  // def __init__(self, x: int, y: float) -> None:
  print_instance_method("__init__", names, types, level);
  level++;

  // x.check(*self.__x_deps)
  for (int i = 0; i < names.size(); ++i) {
    if (!kBuildInTypes.contains(types[i])) {
      std::vector<std::string> tokens = {names[i], ".check(*self.__", names[i], "_deps)"};
      print_line(tokens, level);
    }
  }

  // self.dependencies = (x, y)
  std::string tuple = untyped_args(names);
  print_line({"self.dependencies = ", tuple}, level);
}

void PyPrinter::print_method_construct(const std::string &message_name,
    std::vector<std::string> &names,
    std::vector<std::string> &types,
    int level) {

  print_constructor("construct", message_name, names, types, level);
}

void PyPrinter::print_enum_constructor(const std::string &subclass,
    std::vector<std::string> &names,
    std::vector<std::string> &types,
    int level) {

  std::string def_name = camel_to_snake(subclass);
  print_constructor(def_name, subclass, names, types, level);
}

} // namespace dbuf::gen
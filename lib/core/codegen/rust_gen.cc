#include "core/codegen/rust_gen.h"

#include "core/interning/interned_string.h"

#include <unordered_map>

namespace dbuf::gen {

namespace {

const std::unordered_map<std::string, std::string> primitive_types {
    {"Int8", "i8"},
    {"Int16", "i16"},
    {"Int32", "i32"},
    {"Int64", "i64"},
    {"Int", "i32"},
    {"Float16", "f32"},
    {"Float32", "f32"},
    {"Float64", "f64"},
    {"Float", "f64"},
    {"String", "String"},
    {"Bool", "bool"},
};

bool IsPrimitiveType(const std::string &type) {
  return primitive_types.contains(type);
}

const std::string &GetPrimitiveTypeInRust(const std::string &type) {
  return primitive_types.at(type);
}

std::string Tab(size_t n) {
  return std::string(n, ' ');
}

void DeclareFields(
    const std::shared_ptr<std::ofstream> &output,
    const std::vector<ast::TypedVariable> &fields,
    const size_t indent) {
  for (const auto &field : fields) {
    const auto &dbuf_name = field.type_expression.identifier.name.GetString();
    const auto& type_name = [&]() {
      if (IsPrimitiveType(dbuf_name)) {
        return GetPrimitiveTypeInRust(dbuf_name);
      }
      return std::string{"Box< "} + dbuf_name + std::string{">"};
    }();
    *output << Tab(indent) << field.name << ": " << type_name << "," << std::endl;
  }
}
} // namespace

void RustCodeGenerator::Generate(ast::AST *tree) {
  if (tree == nullptr) {
    std::cerr << "Rust codegen did\'t get AST" << std::endl;
    return;
  }

  *output_ << "// This file was automatically generated by DependoBuf" << std::endl << std::endl;

  for (const auto &struct_name : tree->visit_order) {
    std::variant<ast::Message, ast::Enum> &var = tree->types[struct_name];
    if (std::holds_alternative<ast::Message>(var)) {
      auto &as_message = std::get<ast::Message>(var);
      (*this)(as_message);
    } else if (std::holds_alternative<ast::Enum>(var)) {
      auto &as_enum = std::get<ast::Enum>(var);
      (*this)(as_enum);
    }
  }
}

void RustCodeGenerator::operator()(const ast::Message &ast_message) {
  *output_ << "struct " << ast_message.identifier.name << " {" << std::endl;
  DeclareFields(output_, ast_message.fields, 2);
  *output_ << "}" << std::endl << std::endl;
}

void RustCodeGenerator::operator()(const ast::Enum &ast_enum) {
  *output_ << "enum " << ast_enum.identifier.name << " {" << std::endl;
  for (const auto &rule : ast_enum.pattern_mapping) {
    for (const auto &constructor : rule.outputs) {
      *output_ << Tab(2) << constructor.identifier.name;
      const auto &fields = constructor.fields;
      if (!fields.empty()) {
        *output_ << "{" << std::endl;
        DeclareFields(output_, fields, 4);
        *output_ << Tab(2) << "}";
      }
      *output_ << "," << std::endl;
    }
  }
  *output_ << "}" << std::endl << std::endl;
}

} // namespace dbuf::gen

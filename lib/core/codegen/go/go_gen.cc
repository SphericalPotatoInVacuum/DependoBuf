#include "core/codegen/go/go_gen.h"

#include "core/ast/ast.h"
#include "core/ast/expression.h"
#include "core/interning/interned_string.h"

#include <iostream>

namespace dbuf::gen {

namespace {

static constexpr std::string_view kDoNotEdit          = "THIS FILE IS AUTOGENERATED, DO NOT EDIT IT";
static constexpr std::size_t kIndentLength            = 4;
static constexpr std::string_view kDefaultPackageName = "dbuf";

static const std::unordered_map<std::string, std::string> kPrimitiveTypesMapping = {
    {"Int", "int"},
    {"Int8", "int8"},
    {"Int16", "int16"},
    {"Int32", "int32"},
    {"Int64", "int64"},
    {"Float16", "float32"},
    {"Float32", "float32"},
    {"Float64", "float64"},
    {"String", "string"},
    {"Bool", "bool"},
};

struct GoNamedType {
  std::string name;
  std::string type;
};

struct GoStatementBody {
  std::vector<std::string> expressions;
};

struct GoFunction {
  std::optional<GoNamedType> receiver;
  std::string name;
  std::vector<GoNamedType> generics;
  std::vector<GoNamedType> args;
  std::vector<std::string> return_types;
  std::optional<GoStatementBody> body;
};

struct GoInterface {
  std::string name;
  std::vector<GoFunction> functions;
};

struct GoStruct {
  std::string name;
  std::vector<GoNamedType> fields;
};

struct GoTypeConstraint {
  std::string name;
  std::vector<std::string> types;
};

using GoStatement = std::variant<GoStruct, GoInterface, GoFunction, GoTypeConstraint>;

std::string GetExportName(std::string field_name) {
  if (std::isalpha(field_name[0]) && std::islower(field_name[0])) {
    field_name[0] = std::toupper(field_name[0]);
  }
  return field_name;
}

std::string GetIndent(std::size_t count) {
  return std::string(count * kIndentLength, ' ');
}

class GoWriter {
public:
  GoWriter(std::shared_ptr<std::ofstream> output)
      : output_(output) {}

  void SaveDependencyNames(InternedString type_name, const ast::DependentType &value);

  template <typename T>
  GoWriter &Write(const T &value);

  template <typename T>
  GoWriter &Write(const ast::ScalarValue<T> &value);

private:
  std::shared_ptr<std::ofstream> output_;
  std::unordered_map<InternedString, std::vector<InternedString>> dependency_names_;
};

void GoWriter::SaveDependencyNames(InternedString type_name, const ast::DependentType &value) {
  std::vector<InternedString> names;
  names.reserve(value.type_dependencies.size());
  for (const auto &dependency : value.type_dependencies) {
    names.push_back(dependency.name);
  }
  dependency_names_[type_name] = std::move(names);
}

template <typename T>
GoWriter &GoWriter::Write(const T &value) {
  *output_ << value;
  return *this;
}

template <>
GoWriter &GoWriter::Write(const InternedString &value) {
  Write(value.GetString());
  return *this;
}

template <typename T>
GoWriter &GoWriter::Write(const ast::ScalarValue<T> &value) {
  Write(value.value);
  return *this;
}

template <>
GoWriter &GoWriter::Write(const ast::ScalarValue<std::string> &value) {
  Write('"');
  Write(value.value);
  Write('"');
  return *this;
}

template <>
GoWriter &GoWriter::Write(const ast::Expression &value);

template <>
GoWriter &GoWriter::Write(const ast::BinaryExpression &value) {
  Write("(");
  Write(*value.left);
  Write(" ");
  Write(static_cast<char>(value.type));
  Write(" ");
  Write(*value.right);
  Write(")");
  return *this;
}

template <>
GoWriter &GoWriter::Write(const ast::UnaryExpression &value) {
  *output_ << static_cast<char>(value.type);
  Write(*value.expression);
  return *this;
}

template <>
GoWriter &GoWriter::Write(const ast::TypeExpression &value) {
  Write(value.identifier.name.GetString());
  for (const auto &parameter : value.parameters) {
    Write(" ");
    Write(*parameter);
  }
  return *this;
}

template <>
GoWriter &GoWriter::Write(const ast::Value &value);

template <>
GoWriter &GoWriter::Write(const ast::VarAccess &value) {
  Write("obj.");
  Write(value.var_identifier.name.GetString());
  std::cout << "field cnt: " << value.field_identifiers.size() << std::endl;
  for (const auto &field : value.field_identifiers) {
    Write(".");
    Write(field.name.GetString());
  }
  return *this;
}

template <>
GoWriter &GoWriter::Write(const ast::ConstructedValue &value) {
  Write(value.constructor_identifier.name.GetString());
  Write("{");
  if (!value.fields.empty()) {
    Write('\n');
    bool is_first_field = true;
    for (const auto &[identifier, value] : value.fields) {
      if (is_first_field) {
        is_first_field = false;
      } else {
        Write(", ");
      }
      Write(identifier.name.GetString());
      Write(": ");
      Write(*value);
    }
    Write('\n');
  }
  Write("}");
  return *this;
}

template <>
GoWriter &GoWriter::Write(const ast::Value &value) {
  std::visit([this](const auto &inner_value) { Write(inner_value); }, value);
  return *this;
}

template <>
GoWriter &GoWriter::Write(const ast::Expression &value) {
  std::visit([this](const auto &inner_value) { Write(inner_value); }, value);
  return *this;
}

template <>
GoWriter &GoWriter::Write(const ast::Message &msg) {
  std::cout << "generating message" << std::endl;
  // generate struct
  const std::string &message_name = msg.identifier.name.GetString();
  *output_ << "type " << message_name << " struct {\n";
  if (!msg.type_dependencies.empty()) {
    *output_ << GetIndent(1) << "// dependencies\n";
    for (const auto &dependency : msg.type_dependencies) {
      const auto &dependency_name = dependency.name.GetString();
      std::string dependency_type = dependency.type_expression.identifier.name.GetString();
      if (kPrimitiveTypesMapping.contains(dependency_type)) {
        dependency_type = kPrimitiveTypesMapping.at(dependency_type);
      } else {
        dependency_type = "*" + dependency_type;
      }
      *output_ << GetIndent(1) << dependency_name << ' ' << dependency_type << '\n';
    }
    if (!msg.fields.empty()) {
      *output_ << '\n';
    }
  }
  for (const auto &field : msg.fields) {
    const std::string field_name = GetExportName(field.name.GetString());
    std::string field_type       = field.type_expression.identifier.name.GetString();
    if (kPrimitiveTypesMapping.contains(field_type)) {
      field_type = kPrimitiveTypesMapping.at(field_type);
    } else {
      field_type = "*" + field_type;
    }
    *output_ << GetIndent(1) << field_name << ' ' << field_type << '\n';
  }
  *output_ << "}\n";
  *output_ << '\n';
  // generate New
  *output_ << "func New" << message_name << "(";
  if (!msg.type_dependencies.empty()) {
    bool is_first_argument = true;
    for (const auto &dependency : msg.type_dependencies) {
      const auto &dependency_name = dependency.name.GetString();
      std::string dependency_type = dependency.type_expression.identifier.name.GetString();
      if (kPrimitiveTypesMapping.contains(dependency_type)) {
        dependency_type = kPrimitiveTypesMapping.at(dependency_type);
      } else {
        dependency_type = "*" + dependency_type;
      }
      if (is_first_argument) {
        is_first_argument = false;
        *output_ << dependency_name << ' ' << dependency_type;
      } else {
        *output_ << ", " << dependency_name << ' ' << dependency_type;
      }
    }
  }
  *output_ << ") *" << message_name << " {\n";
  *output_ << GetIndent(1) << "return &" << message_name << "{";
  if (!msg.type_dependencies.empty()) {
    *output_ << '\n';
    *output_ << GetIndent(2);
    for (const auto &dependency : msg.type_dependencies) {
      const auto &dependency_name = dependency.name.GetString();
      *output_ << dependency_name << ": " << dependency_name << ", ";
    }
    *output_ << '\n';
    *output_ << GetIndent(1) << "}\n";
  } else {
    *output_ << "}\n";
  }
  *output_ << "}\n";
  *output_ << '\n';
  // generate Validate
  *output_ << "func(obj *" << message_name << ") Validate() bool {";
  if (!msg.type_dependencies.empty() || !msg.fields.empty()) {
    *output_ << '\n';
  }
  for (const auto &dependency : msg.type_dependencies) {
    if (dependency.type_expression.parameters.empty()) {
      continue;
    }
    const auto &dependency_type = dependency.type_expression.identifier.name.GetString();
    *output_ << GetIndent(1) << "if (";
    bool is_first_condition = true;
    for (const auto &type_parameter_ptr : dependency.type_expression.parameters) {
      if (is_first_condition) {
        is_first_condition = false;
      } else {
        *output_ << " || ";
      }
      *output_ << "obj." << dependency.name.GetString() << " != ";
      GoWriter writer {output_};
      std::visit([&writer](const auto &parameter) { writer.Write(parameter); }, *type_parameter_ptr);
    }
    *output_ << ") {\n";
    *output_ << GetIndent(2) << "return false;\n";
    *output_ << GetIndent(1) << "}\n";
  }
  *output_ << GetIndent(1) << "return true;\n";
  *output_ << "}\n";
  *output_ << "\n";
  return *this;
}

template <>
GoWriter &GoWriter::Write(const ast::Enum &en) {
  std::cout << "generating enum" << std::endl;
  // generate struct
  const auto &enum_name = en.identifier.name.GetString();
  *output_ << "type " << enum_name << " struct {\n";
  for (const auto &dependency : en.type_dependencies) {
    const std::string dependency_name = dependency.name.GetString();
    std::string dependency_type       = dependency.type_expression.identifier.name.GetString();
    if (kPrimitiveTypesMapping.contains(dependency_type)) {
      dependency_type = kPrimitiveTypesMapping.at(dependency_type);
    } else {
      dependency_type = "*" + dependency_type;
    }
    *output_ << GetIndent(1) << dependency_name << ' ' << dependency_type << '\n';
  }
  *output_ << '\n';
  *output_ << GetIndent(1) << "InternalValue interface{}\n";
  *output_ << "}\n";
  *output_ << '\n';
  // constructors
  std::vector<std::string> constructor_names;
  for (const auto &pattern : en.pattern_mapping) {
    for (const auto &constructor : pattern.outputs) {
      const auto &constructor_name = constructor.identifier.name.GetString();
      constructor_names.push_back(constructor_name);
      *output_ << "type " << constructor_name << " struct {\n";
      for (const auto &field : constructor.fields) {
        const std::string field_name = GetExportName(field.name.GetString());
        std::string field_type       = field.type_expression.identifier.name.GetString();
        if (kPrimitiveTypesMapping.contains(field_type)) {
          field_type = kPrimitiveTypesMapping.at(field_type);
        } else {
          field_type = "*" + field_type;
        }
        *output_ << GetIndent(1) << field_name << ' ' << field_type << '\n';
      }
      *output_ << "}\n";
      *output_ << '\n';
    }
  }
  // type constraint
  const std::string type_constraint_name = en.identifier.name.GetString() + "TypeConstraint";
  *output_ << "type " << type_constraint_name << " interface {";
  if (!constructor_names.empty()) {
    *output_ << '\n';
    *output_ << GetIndent(1);
  }
  bool is_first_name = true;
  for (const auto &constructor_name : constructor_names) {
    if (is_first_name) {
      is_first_name = false;
      *output_ << constructor_name;
    } else {
      *output_ << " | " << constructor_name;
    }
  }
  *output_ << "\n";
  *output_ << "}\n";
  *output_ << '\n';
  // generate New
  *output_ << "func New" << enum_name << "(";
  if (!en.type_dependencies.empty()) {
    bool is_first_argument = true;
    for (const auto &dependency : en.type_dependencies) {
      const auto &dependency_name = dependency.name.GetString();
      std::string dependency_type = dependency.type_expression.identifier.name.GetString();
      if (kPrimitiveTypesMapping.contains(dependency_type)) {
        dependency_type = kPrimitiveTypesMapping.at(dependency_type);
      } else {
        dependency_type = "*" + dependency_type;
      }
      if (is_first_argument) {
        is_first_argument = false;
        *output_ << dependency_name << ' ' << dependency_type;
      } else {
        *output_ << ", " << dependency_name << ' ' << dependency_type;
      }
    }
  }
  *output_ << ") *" << enum_name << " {\n";
  *output_ << GetIndent(1) << "return &" << enum_name << "{";
  if (!en.type_dependencies.empty()) {
    *output_ << '\n';
    *output_ << GetIndent(2);
    for (const auto &dependency : en.type_dependencies) {
      const auto &dependency_name = dependency.name.GetString();
      *output_ << dependency_name << ": " << dependency_name << ", ";
    }
    *output_ << '\n';
    *output_ << GetIndent(1) << "}\n";
  } else {
    *output_ << "}\n";
  }
  *output_ << "}\n";
  *output_ << '\n';
  // SetValue
  *output_ << "func SetValue" << enum_name << "[T " << type_constraint_name << "](enum *" << enum_name << ", "
           << "value *T) {\n";
  *output_ << GetIndent(1) << "enum.InternalValue = value\n";
  *output_ << "}\n";
  *output_ << '\n';
  return *this;
}

} // namespace

void GoCodeGenerator::Generate(ast::AST *tree) {
  GoWriter writer(output_);

  *output_ << "package " << kDefaultPackageName << "\n\n";
  *output_ << "// " << kDoNotEdit << "\n\n";
  for (const auto &item : tree->visit_order) {
    const auto &variant = tree->types.at(item);
    std::visit([&writer, &item](const auto &entity) { writer.SaveDependencyNames(item, entity); }, variant);
  }
  for (const auto &item : tree->visit_order) {
    const auto &variant = tree->types.at(item);
    std::visit([&writer, &item](const auto &entity) { writer.Write(entity); }, variant);
  }
}

} // namespace dbuf::gen

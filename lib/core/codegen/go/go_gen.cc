#include "core/codegen/go/go_gen.h"

#include "core/ast/ast.h"

#include <iostream>

namespace dbuf::gen {

namespace {

static constexpr std::string_view kDoNotEdit          = "THIS FILE IS AUTOGENERATED, DO NOT EDIT IT";
static constexpr std::size_t kIndentLength            = 4;
static constexpr std::string_view kDefaultPackageName = "dbuf";

static const std::unordered_map<std::string, std::string> kPrimitiveTypesMapping = {
    {"Int", "int"},
    {"Int8", "int8"},
    {"Int16", "int16"},
    {"Int32", "int32"},
    {"Int64", "int64"},
    {"Float16", "float32"},
    {"Float32", "float32"},
    {"Float64", "float64"},
    {"String", "string"},
    {"Bool", "bool"},
};

struct GoNamedType {
  std::string name;
  std::string type;
};

struct GoStatementBody {
  std::vector<std::string> expressions;
};

struct GoFunction {
  std::optional<GoNamedType> receiver;
  std::string name;
  std::vector<GoNamedType> generics;
  std::vector<GoNamedType> args;
  std::vector<std::string> return_types;
  std::optional<GoStatementBody> body;
};

struct GoInterface {
  std::string name;
  std::vector<GoFunction> functions;
};

struct GoStruct {
  std::string name;
  std::vector<GoNamedType> fields;
};

struct GoTypeConstraint {
  std::string name;
  std::vector<std::string> types;
};

using GoStatement = std::variant<GoStruct, GoInterface, GoFunction, GoTypeConstraint>;

std::string GetExportName(std::string field_name) {
  if (std::isalpha(field_name[0]) && std::islower(field_name[0])) {
    field_name[0] = std::toupper(field_name[0]);
  }
  return field_name;
}

std::string GetIndent(std::size_t count) {
  return std::string(count * kIndentLength, ' ');
}

} // namespace

void GoCodeGenerator::GenerateObject(const ast::Message &msg) {
  std::cout << "generating message" << std::endl;
  // generate struct
  const std::string &message_name = msg.identifier.name.GetString();
  *output_ << "type " << message_name << " struct {\n";
  if (!msg.type_dependencies.empty()) {
    *output_ << GetIndent(1) << "// dependencies\n";
    for (const auto &dependency : msg.type_dependencies) {
      const auto &dependency_name = dependency.name.GetString();
      std::string dependency_type = dependency.type_expression.identifier.name.GetString();
      if (kPrimitiveTypesMapping.contains(dependency_type)) {
        dependency_type = kPrimitiveTypesMapping.at(dependency_type);
      } else {
        dependency_type = "*" + dependency_type;
      }
      *output_ << GetIndent(1) << dependency_name << ' ' << dependency_type << '\n';
    }
    if (!msg.fields.empty()) {
      *output_ << '\n';
    }
  }
  for (const auto &field : msg.fields) {
    const std::string field_name = GetExportName(field.name.GetString());
    std::string field_type       = field.type_expression.identifier.name.GetString();
    if (kPrimitiveTypesMapping.contains(field_type)) {
      field_type = kPrimitiveTypesMapping.at(field_type);
    } else {
      field_type = "*" + field_type;
    }
    *output_ << GetIndent(1) << field_name << ' ' << field_type << '\n';
  }
  *output_ << "}\n";
  *output_ << '\n';
  // generate New
  *output_ << "func New" << message_name << "(";
  if (!msg.type_dependencies.empty()) {
    bool is_first_argument = true;
    for (const auto &dependency : msg.type_dependencies) {
      const auto &dependency_name = dependency.name.GetString();
      std::string dependency_type = dependency.type_expression.identifier.name.GetString();
      if (kPrimitiveTypesMapping.contains(dependency_type)) {
        dependency_type = kPrimitiveTypesMapping.at(dependency_type);
      } else {
        dependency_type = "*" + dependency_type;
      }
      if (is_first_argument) {
        is_first_argument = false;
        *output_ << dependency_name << ' ' << dependency_type;
      } else {
        *output_ << ", " << dependency_name << ' ' << dependency_type;
      }
    }
  }
  *output_ << ") *" << message_name << " {\n";
  *output_ << GetIndent(1) << "return &" << message_name << "{";
  if (!msg.type_dependencies.empty()) {
    *output_ << '\n';
    *output_ << GetIndent(2);
    for (const auto &dependency : msg.type_dependencies) {
      const auto &dependency_name = dependency.name.GetString();
      *output_ << dependency_name << ": " << dependency_name << ", ";
    }
    *output_ << '\n';
    *output_ << GetIndent(1) << "}\n";
  } else {
    *output_ << "}\n";
  }
  *output_ << "}\n";
  *output_ << '\n';
}

void GoCodeGenerator::GenerateObject(const ast::Enum &en) {
  std::cout << "generating enum" << std::endl;
  // generate struct
  const auto &enum_name = en.identifier.name.GetString();
  *output_ << "type " << enum_name << " struct {\n";
  for (const auto &dependency : en.type_dependencies) {
    const std::string dependency_name = dependency.name.GetString();
    std::string dependency_type       = dependency.type_expression.identifier.name.GetString();
    if (kPrimitiveTypesMapping.contains(dependency_type)) {
      dependency_type = kPrimitiveTypesMapping.at(dependency_type);
    } else {
      dependency_type = "*" + dependency_type;
    }
    *output_ << GetIndent(1) << dependency_name << ' ' << dependency_type << '\n';
  }
  *output_ << '\n';
  *output_ << GetIndent(1) << "InternalValue interface{}\n";
  *output_ << "}\n";
  *output_ << '\n';
  // constructors
  std::vector<std::string> constructor_names;
  for (const auto &pattern : en.pattern_mapping) {
    for (const auto &constructor : pattern.outputs) {
      const auto &constructor_name = constructor.identifier.name.GetString();
      constructor_names.push_back(constructor_name);
      *output_ << "type " << constructor_name << " struct {\n";
      for (const auto &field : constructor.fields) {
        const std::string field_name = GetExportName(field.name.GetString());
        std::string field_type       = field.type_expression.identifier.name.GetString();
        if (kPrimitiveTypesMapping.contains(field_type)) {
          field_type = kPrimitiveTypesMapping.at(field_type);
        } else {
          field_type = "*" + field_type;
        }
        *output_ << GetIndent(1) << field_name << ' ' << field_type << '\n';
      }
      *output_ << "}\n";
      *output_ << '\n';
    }
  }
  // type constraint
  const std::string type_constraint_name = en.identifier.name.GetString() + "TypeConstraint";
  *output_ << "type " << type_constraint_name << " interface {";
  if (!constructor_names.empty()) {
    *output_ << '\n';
    *output_ << GetIndent(1);
  }
  bool is_first_name = true;
  for (const auto &constructor_name : constructor_names) {
    if (is_first_name) {
      is_first_name = false;
      *output_ << constructor_name;
    } else {
      *output_ << " | " << constructor_name;
    }
  }
  *output_ << "\n";
  *output_ << "}\n";
  *output_ << '\n';
  // generate New
  *output_ << "func New" << enum_name << "(";
  if (!en.type_dependencies.empty()) {
    bool is_first_argument = true;
    for (const auto &dependency : en.type_dependencies) {
      const auto &dependency_name = dependency.name.GetString();
      std::string dependency_type = dependency.type_expression.identifier.name.GetString();
      if (kPrimitiveTypesMapping.contains(dependency_type)) {
        dependency_type = kPrimitiveTypesMapping.at(dependency_type);
      } else {
        dependency_type = "*" + dependency_type;
      }
      if (is_first_argument) {
        is_first_argument = false;
        *output_ << dependency_name << ' ' << dependency_type;
      } else {
        *output_ << ", " << dependency_name << ' ' << dependency_type;
      }
    }
  }
  *output_ << ") *" << enum_name << " {\n";
  *output_ << GetIndent(1) << "return &" << enum_name << "{";
  if (!en.type_dependencies.empty()) {
    *output_ << '\n';
    *output_ << GetIndent(2);
    for (const auto &dependency : en.type_dependencies) {
      const auto &dependency_name = dependency.name.GetString();
      *output_ << dependency_name << ": " << dependency_name << ", ";
    }
    *output_ << '\n';
    *output_ << GetIndent(1) << "}\n";
  } else {
    *output_ << "}\n";
  }
  *output_ << "}\n";
  *output_ << '\n';
  // SetValue
  *output_ << "func SetValue" << enum_name << "[T " << type_constraint_name << "](enum *" << enum_name << ", "
           << "value *T) {\n";
  *output_ << GetIndent(1) << "enum.InternalValue = value\n";
  *output_ << "}\n";
  *output_ << '\n';
}

void GoCodeGenerator::Generate(ast::AST *tree) {
  *output_ << "package " << kDefaultPackageName << "\n\n";
  *output_ << "// " << kDoNotEdit << "\n\n";
  for (const auto &item : tree->visit_order) {
    const auto &variant = tree->types.at(item);
    std::visit([this](const auto &entity) { GenerateObject(entity); }, variant);
  }
}

} // namespace dbuf::gen

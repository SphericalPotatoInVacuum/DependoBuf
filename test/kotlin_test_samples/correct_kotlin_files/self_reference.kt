package dbuf

// This file is autogenerated. Please, do not change it manually.

class Leaf(val height: Long) {
    @Throws(IllegalStateException::class) constructor(height: Long, @Suppress("UNUSED_PARAMETER") _unused: Any) : this(height){
        check()
    }

    fun check() {
    }

    override fun equals(other: Any?): Boolean {
        if (other !is Leaf) return false

        if (this.height != other.height) return false

        return true
    }

    override fun toString(): String {
        return toString(1U)
    }

    fun toString(depth: UInt): String {
        if (depth == 0U) return "dbuf.Leaf@${hashCode().toString(radix=16)}"
        return "Leaf <height = $height> {}"
    }

    infix internal fun sameFields(other: Any?): Boolean {
        if (other !is Leaf) return false

        return true
    }

    infix internal fun notSameFields(other: Any?): Boolean {
        return !(this sameFields other)
    }

    internal companion object Factory {
        fun default() : Leaf {
            var return_object = Leaf(0L)
            return return_object
        }
        fun make(): Tree {
            var return_object = Tree.default()
            var inside_object = Leaf.default()
            return_object.inside = inside_object
            return return_object
        }
    }
}

class Node(val height: Long) {
    lateinit var l: Tree
    lateinit var r: Tree
    var value: Long = 0L

    @Throws(IllegalStateException::class) constructor(height: Long, l: Tree, r: Tree, value: Long) : this(height){
        this.l = l
        this.r = r
        this.value = value

        check()
    }

    fun check() {
        check(this::l.isInitialized) {"property l should be initialized"}
        check(this::r.isInitialized) {"property r should be initialized"}

        check(l.height == (height - 1L)) {"dependency height of l (is ${l.height}) should be ${(height - 1L)}"}
        check(r.height == (height - 1L)) {"dependency height of r (is ${r.height}) should be ${(height - 1L)}"}
    }

    override fun equals(other: Any?): Boolean {
        if (other !is Node) return false

        if (this.height != other.height) return false

        if (this.l != other.l) return false
        if (this.r != other.r) return false
        if (this.value != other.value) return false

        return true
    }

    override fun toString(): String {
        return toString(1U)
    }

    fun toString(depth: UInt): String {
        if (depth == 0U) return "dbuf.Node@${hashCode().toString(radix=16)}"
        return "Node <height = $height> {l: ${l.toString(depth-1U)}, r: ${r.toString(depth-1U)}, value: $value}"
    }

    infix internal fun sameFields(other: Any?): Boolean {
        if (other !is Node) return false

        if (this.l notSameFields other.l) return false
        if (this.r notSameFields other.r) return false
        if (this.value != other.value) return false

        return true
    }

    infix internal fun notSameFields(other: Any?): Boolean {
        return !(this sameFields other)
    }

    internal companion object Factory {
        fun default() : Node {
            var return_object = Node(0L)
            return return_object
        }
        fun make(l: Tree, r: Tree, value: Long): Tree {
            var return_object = Tree.default()
            var inside_object = Node.default()
            inside_object.l = l
            inside_object.r = r
            inside_object.value = value
            return_object.inside = inside_object
            return return_object
        }
    }
}

class Tree(val height: Long) {
    lateinit var inside: Any

    @Throws(IllegalStateException::class) constructor(height: Long, inside: Any) : this(height) {
        this.inside = inside
        check()
    }

    fun check() {
        check(this::inside.isInitialized) {"property inside should be initialized"}

        if (height == 0L) {
            if (inside is Leaf) (inside as Leaf).check()
            else check(false) {"not valid inside"}
            return
        }
        if (true) {
            if (inside is Node) (inside as Node).check()
            else check(false) {"not valid inside"}
            return
        }
        check(false) {"not valid inside"}
    }

    override fun equals(other: Any?): Boolean {
        if (other !is Tree) return false

        if (inside is Leaf) return (inside as Leaf).equals(other.inside)
        if (inside is Node) return (inside as Node).equals(other.inside)

        check(false) {"not valid inside"}
        return false
    }

    override fun toString(): String {
        return toString(1U)
    }

    fun toString(depth: UInt): String {
        if (depth == 0U) return "dbuf.Tree@${hashCode().toString(radix=16)}"

        if (inside is Leaf) return "(Tree) ${(inside as Leaf).toString(depth)}"
        if (inside is Node) return "(Tree) ${(inside as Node).toString(depth)}"

        check(false) {"not valid inside"}
        return "(Tree) Unknow"
    }

    infix internal fun sameFields(other: Any?): Boolean {
        if (other !is Tree) return false

        if (inside is Leaf) return (inside as Leaf).sameFields(other.inside)
        if (inside is Node) return (inside as Node).sameFields(other.inside)

        check(false) {"not valid inside"}
        return false
    }

    infix internal fun notSameFields(other: Any?): Boolean {
        return !(this sameFields other)
    }

    internal companion object Factory {
        fun default() : Tree {
            var return_object = Tree(0L)
            return return_object
        }
    }
}

class TreeD(val x: Long, val t: Tree) {
    @Throws(IllegalStateException::class) constructor(x: Long, t: Tree, @Suppress("UNUSED_PARAMETER") _unused: Any) : this(x, t){
        check()
    }

    fun check() {
        check(t.height == x) {"dependency height of t (is ${t.height}) should be ${x}"}
    }

    override fun equals(other: Any?): Boolean {
        if (other !is TreeD) return false

        if (this.x != other.x) return false
        if (this.t != other.t) return false

        return true
    }

    override fun toString(): String {
        return toString(1U)
    }

    fun toString(depth: UInt): String {
        if (depth == 0U) return "dbuf.TreeD@${hashCode().toString(radix=16)}"
        return "TreeD <x = $x, t = ${t.toString(depth-1U)}> {}"
    }

    infix internal fun sameFields(other: Any?): Boolean {
        if (other !is TreeD) return false

        return true
    }

    infix internal fun notSameFields(other: Any?): Boolean {
        return !(this sameFields other)
    }

    internal companion object Factory {
        fun default() : TreeD {
            var return_object = TreeD(0L, Tree.default())
            return return_object
        }
        fun make(): TreeD {
            var return_object = TreeD.default()
            return return_object
        }
    }
}

class IWantedBiggerTree() {
    lateinit var tree: TreeD

    @Throws(IllegalStateException::class) constructor(tree: TreeD) : this(){
        this.tree = tree

        check()
    }

    fun check() {
        check(this::tree.isInitialized) {"property tree should be initialized"}

        check(tree.x == 0L) {"dependency x of tree (is ${tree.x}) should be ${0L}"}
        check(tree.t sameFields Leaf.make()) {"dependency t of tree (is ${tree.t}) should be ${Leaf.make()}"}
    }

    override fun equals(other: Any?): Boolean {
        if (other !is IWantedBiggerTree) return false

        if (this.tree != other.tree) return false

        return true
    }

    override fun toString(): String {
        return toString(1U)
    }

    fun toString(depth: UInt): String {
        if (depth == 0U) return "dbuf.IWantedBiggerTree@${hashCode().toString(radix=16)}"
        return "IWantedBiggerTree {tree: ${tree.toString(depth-1U)}}"
    }

    infix internal fun sameFields(other: Any?): Boolean {
        if (other !is IWantedBiggerTree) return false

        if (this.tree notSameFields other.tree) return false

        return true
    }

    infix internal fun notSameFields(other: Any?): Boolean {
        return !(this sameFields other)
    }

    internal companion object Factory {
        fun default() : IWantedBiggerTree {
            var return_object = IWantedBiggerTree()
            return return_object
        }
        fun make(tree: TreeD): IWantedBiggerTree {
            var return_object = IWantedBiggerTree.default()
            return_object.tree = tree
            return return_object
        }
    }
}


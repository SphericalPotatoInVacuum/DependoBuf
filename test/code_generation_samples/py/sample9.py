# This file was automatically generated by DependoBuf.
# Please do not change it.

from __future__ import annotations
from annotated_types import Ge
from dataclasses import dataclass
from typing import Annotated

Unsigned = Annotated[int, Ge(0)]


class Message0:
    @dataclass
    class __Message0:
        name: str

        def check(self, u: Unsigned) -> None:
            if type(self) not in Message0.possible_types(u):
                raise TypeError('Non-compliance with type dependencies')

    message0_type = __Message0
    __u_deps = []

    @classmethod
    def possible_types(cls, u: Unsigned) -> set[type]:
        return {}

    def __init__(self, u: Unsigned) -> None:
        self.dependencies = (u)

    def construct(self, name: str) -> __Message0:
        obj = self.__Message0(name)
        obj.check(*self.dependencies)
        return obj


class Message1:
    @dataclass
    class __Message1:
        surname: str

        def check(self, u: Unsigned, m0: Message0.message0_type) -> None:
            if type(self) not in Message1.possible_types(u, m0):
                raise TypeError('Non-compliance with type dependencies')

    message1_type = __Message1
    __u_deps = []
    __m0_deps = []

    @classmethod
    def possible_types(cls, u: Unsigned, m0: Message0.message0_type) -> set[type]:
        return {}

    def __init__(self, u: Unsigned, m0: Message0.message0_type) -> None:
        m0.check(*self.__m0_deps)
        self.dependencies = (u, m0)

    def construct(self, surname: str) -> __Message1:
        obj = self.__Message1(surname)
        obj.check(*self.dependencies)
        return obj


class Message2:
    @dataclass
    class __Message2:
        nickname: str

        def check(self, u: Unsigned, m0: Message0.message0_type, m1: Message1.message1_type) -> None:
            if type(self) not in Message2.possible_types(u, m0, m1):
                raise TypeError('Non-compliance with type dependencies')

    message2_type = __Message2
    __u_deps = []
    __m0_deps = []
    __m1_deps = []

    @classmethod
    def possible_types(cls, u: Unsigned, m0: Message0.message0_type, m1: Message1.message1_type) -> set[type]:
        return {}

    def __init__(self, u: Unsigned, m0: Message0.message0_type, m1: Message1.message1_type) -> None:
        m0.check(*self.__m0_deps)
        m1.check(*self.__m1_deps)
        self.dependencies = (u, m0, m1)

    def construct(self, nickname: str) -> __Message2:
        obj = self.__Message2(nickname)
        obj.check(*self.dependencies)
        return obj


class Message3:
    @dataclass
    class __Message3:
        password: str

        def check(self, u: Unsigned, m0: Message0.message0_type, m1: Message1.message1_type, m2: Message2.message2_type) -> None:
            if type(self) not in Message3.possible_types(u, m0, m1, m2):
                raise TypeError('Non-compliance with type dependencies')

    message3_type = __Message3
    __u_deps = []
    __m0_deps = []
    __m1_deps = []
    __m2_deps = []

    @classmethod
    def possible_types(cls, u: Unsigned, m0: Message0.message0_type, m1: Message1.message1_type, m2: Message2.message2_type) -> set[type]:
        return {}

    def __init__(self, u: Unsigned, m0: Message0.message0_type, m1: Message1.message1_type, m2: Message2.message2_type) -> None:
        m0.check(*self.__m0_deps)
        m1.check(*self.__m1_deps)
        m2.check(*self.__m2_deps)
        self.dependencies = (u, m0, m1, m2)

    def construct(self, password: str) -> __Message3:
        obj = self.__Message3(password)
        obj.check(*self.dependencies)
        return obj


class Message4:
    @dataclass
    class __Message4:
        m3: Message3.message3_type

        def check(self, u: Unsigned, m0: Message0.message0_type, m1: Message1.message1_type, m2: Message2.message2_type) -> None:
            if type(self) not in Message4.possible_types(u, m0, m1, m2):
                raise TypeError('Non-compliance with type dependencies')

    message4_type = __Message4
    __u_deps = []
    __m0_deps = []
    __m1_deps = []
    __m2_deps = []

    @classmethod
    def possible_types(cls, u: Unsigned, m0: Message0.message0_type, m1: Message1.message1_type, m2: Message2.message2_type) -> set[type]:
        return {}

    def __init__(self, u: Unsigned, m0: Message0.message0_type, m1: Message1.message1_type, m2: Message2.message2_type) -> None:
        m0.check(*self.__m0_deps)
        m1.check(*self.__m1_deps)
        m2.check(*self.__m2_deps)
        self.dependencies = (u, m0, m1, m2)

    def construct(self, m3: Message3.message3_type) -> __Message4:
        obj = self.__Message4(m3)
        obj.check(*self.dependencies)
        return obj

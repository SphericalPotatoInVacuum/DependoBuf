# This file was automatically generated by DependoBuf.
# Please do not change it.

from __future__ import annotations

from annotated_types import Ge
from dataclasses import dataclass
from typing import Annotated

Unsigned = Annotated[int, Ge(0)]


class Message2:
    @dataclass
    class __Message2:
        name: str
        id: Unsigned
        a: int
        b: float

        def check(self) -> None:
            if type(self) not in Message2.possible_types():
                raise TypeError('Non-compliance with type dependencies')

    message2_type = __Message2

    @classmethod
    def possible_types(cls) -> set[type]:
        return {}

    def __init__(self) -> None:
        self.dependencies = ()

    def construct(self, name: str, id: Unsigned, a: int, b: float) -> __Message2:
        obj = self.__Message2(name, id, a, b)
        obj.check(*self.dependencies)
        return obj


class Message3:
    @dataclass
    class __Message3:
        x: int
        y: int

        def check(self, m2: Message2.message2_type) -> None:
            if type(self) not in Message3.possible_types(m2):
                raise TypeError('Non-compliance with type dependencies')

    message3_type = __Message3

    @classmethod
    def possible_types(cls, m2: Message2.message2_type) -> set[type]:
        return {}

    def __init__(self, m2: Message2.message2_type) -> None:
        self.dependencies = (m2)

    def construct(self, x: int, y: int) -> __Message3:
        obj = self.__Message3(x, y)
        obj.check(*self.dependencies)
        return obj


class Message4:
    @dataclass
    class __Message4:
        m3: Message3.message3_type

        def check(self) -> None:
            if type(self) not in Message4.possible_types():
                raise TypeError('Non-compliance with type dependencies')

    message4_type = __Message4

    @classmethod
    def possible_types(cls) -> set[type]:
        return {}

    def __init__(self) -> None:
        self.dependencies = ()

    def construct(self, m3: Message3.message3_type) -> __Message4:
        obj = self.__Message4(m3)
        obj.check(*self.dependencies)
        return obj


class Message5:
    @dataclass
    class __Message5:

        def check(self, m3: Message3.message3_type) -> None:
            if type(self) not in Message5.possible_types(m3):
                raise TypeError('Non-compliance with type dependencies')

    message5_type = __Message5

    @classmethod
    def possible_types(cls, m3: Message3.message3_type) -> set[type]:
        return {}

    def __init__(self, m3: Message3.message3_type) -> None:
        m3_deps = (Message2.__Message2('Evgeny', 1, 10, 20))
        m3.check(*m3_deps)
        self.dependencies = (m3)

    def construct(self) -> __Message5:
        obj = self.__Message5()
        obj.check(*self.dependencies)
        return obj


mu2 = Message2().construct(name='Evgeny', id=2, a=)
# This file was automatically generated by DependoBuf.
# Please do not change it.

from __future__ import annotations

from annotated_types import Ge
from dataclasses import dataclass
from typing import Annotated

Unsigned = Annotated[int, Ge(0)]


def _is_consistent(actual: tuple, expected: tuple) -> bool:
    for i in range(len(actual)):
        if expected[i] is None:
            continue

        if actual[i] != expected[i]:
            return False

    return True


class Cat:
    @dataclass
    class __Child:
        name: str

        def check(self, age: int) -> None:
            if type(self) not in Cat.possible_types(age):
                raise TypeError('Non-compliance with type dependencies')

    @dataclass
    class __Adult:
        name: str

        def check(self, age: int) -> None:
            if type(self) not in Cat.possible_types(age):
                raise TypeError('Non-compliance with type dependencies')

    cat_type = __Child | __Adult

    @classmethod
    def possible_types(cls, age: int) -> set[type]:
        actual = (age, )
        expected = (0, )
        if _is_consistent(actual, expected):
            return {cls.__Child}

        expected = (None, )
        if _is_consistent(actual, expected):
            return {cls.__Adult}

        return {}

    def __init__(self, age: int) -> None:
        self.dependencies = (age, )

    def child(self, name: str) -> __Child:
        obj = self.__Child(name)
        obj.check(*self.dependencies)
        return obj

    def adult(self, name: str) -> __Adult:
        obj = self.__Adult(name)
        obj.check(*self.dependencies)
        return obj


class House:
    @dataclass
    class __House:
        cat: Cat.cat_type

        def check(self, n: int) -> None:
            if type(self) not in House.possible_types(n):
                raise TypeError('Non-compliance with type dependencies')

            cat_deps = ((-(n + 5)) - (-2), )
            self.cat.check(*cat_deps)

    house_type = __House

    @classmethod
    def possible_types(cls, n: int) -> set[type]:
        return {cls.__House}

    def __init__(self, n: int) -> None:
        self.dependencies = (n, )

    def construct(self, cat: Cat.cat_type) -> __House:
        obj = self.__House(cat)
        obj.check(*self.dependencies)
        return obj

# This file was automatically generated by DependoBuf.
# Please do not change it.

from __future__ import annotations

from annotated_types import Ge
from dataclasses import dataclass
from typing import Annotated

Unsigned = Annotated[int, Ge(0)]


class Color:
    @dataclass
    class __Red:
        r: int

        def check(self, s: str) -> None:
            if type(self) not in Color.possible_types(s):
                raise TypeError('Non-compliance with type dependencies')
    @dataclass
    class __Green:
        g: int

        def check(self, s: str) -> None:
            if type(self) not in Color.possible_types(s):
                raise TypeError('Non-compliance with type dependencies')

    color_type = __Red | __Green

    @classmethod
    def possible_types(cls, s: str) -> set[type]:
        return {}

    def __init__(self, s: str) -> None:
        self.dependencies = (s)

    def red(self, r: int) -> __Red:
        obj = self.__Red(r)
        obj.check(*self.dependencies)
        return obj

    def green(self, g: int) -> __Green:
        obj = self.__Green(g)
        obj.check(*self.dependencies)
        return obj


class Painter:
    @dataclass
    class __Painter:

        def check(self, f: float, c: Color.color_type) -> None:
            if type(self) not in Painter.possible_types(f, c):
                raise TypeError('Non-compliance with type dependencies')

    painter_type = __Painter

    @classmethod
    def possible_types(cls, f: float, c: Color.color_type) -> set[type]:
        return {}

    def __init__(self, f: float, c: Color.color_type) -> None:
        c_deps = ('green')
        c.check(*c_deps)
        self.dependencies = (f, c)

    def construct(self) -> __Painter:
        obj = self.__Painter()
        obj.check(*self.dependencies)
        return obj


class Painting:
    @dataclass
    class __Painting:

        def check(self, col: str, c: Color.color_type) -> None:
            if type(self) not in Painting.possible_types(col, c):
                raise TypeError('Non-compliance with type dependencies')

    painting_type = __Painting

    @classmethod
    def possible_types(cls, col: str, c: Color.color_type) -> set[type]:
        return {}

    def __init__(self, col: str, c: Color.color_type) -> None:
        c_deps = (col)
        c.check(*c_deps)
        self.dependencies = (col, c)

    def construct(self) -> __Painting:
        obj = self.__Painting()
        obj.check(*self.dependencies)
        return obj


class Museum:
    @dataclass
    class __Museum:

        def check(self, f: float, p: Painter.painter_type, art: Painting.painting_type, ccc: Color.color_type) -> None:
            if type(self) not in Museum.possible_types(f, p, art, ccc):
                raise TypeError('Non-compliance with type dependencies')

    museum_type = __Museum

    @classmethod
    def possible_types(cls, f: float, p: Painter.painter_type, art: Painting.painting_type, ccc: Color.color_type) -> set[type]:
        return {}

    def __init__(self, f: float, p: Painter.painter_type, art: Painting.painting_type, ccc: Color.color_type) -> None:
        p_deps = (2 + f, Color.__Green(12))
        p.check(*p_deps)
        art_deps = ('red', Color.__Red(22))
        art.check(*art_deps)
        ccc_deps = ('yellow')
        ccc.check(*ccc_deps)
        self.dependencies = (f, p, art, ccc)

    def construct(self) -> __Museum:
        obj = self.__Museum()
        obj.check(*self.dependencies)
        return obj

# This file was automatically generated by DependoBuf.
# Please do not change it.

from __future__ import annotations

from annotated_types import Ge
from dataclasses import dataclass
from typing import Annotated

Unsigned = Annotated[int, Ge(0)]


def __is_consistent(actual: tuple, expected: tuple) -> bool:
    for i in range(len(actual)):
        if expected[i] is None:
            continue

        if actual[i] != expected[i]:
            return False

    return True


class Color:
    @dataclass
    class __Red:
        r: int

        def check(self, s: str) -> None:
            if type(self) not in Color.possible_types(s):
                raise TypeError('Non-compliance with type dependencies')
    @dataclass
    class __Green:
        g: int

        def check(self, s: str) -> None:
            if type(self) not in Color.possible_types(s):
                raise TypeError('Non-compliance with type dependencies')

    color_type = __Red | __Green

    @classmethod
    def possible_types(cls, s: str) -> set[type]:
        actual = (s, )
        

    def __init__(self, s: str) -> None:
        self.dependencies = (s, )

    def red(self, r: int) -> __Red:
        obj = self.__Red(r)
        obj.check(*self.dependencies)
        return obj

    def green(self, g: int) -> __Green:
        obj = self.__Green(g)
        obj.check(*self.dependencies)
        return obj


class Painter:
    @dataclass
    class __Painter:

        def check(self, f: float, c: Color.color_type) -> None:
            if type(self) not in Painter.possible_types(f, c):
                raise TypeError('Non-compliance with type dependencies')

    painter_type = __Painter

    @classmethod
    def possible_types(cls, f: float, c: Color.color_type) -> set[type]:
        return {}

    def __init__(self, f: float, c: Color.color_type) -> None:
        c_deps = ('green', )
        c.check(*c_deps)

        self.dependencies = (f, c, )

    def construct(self) -> __Painter:
        obj = self.__Painter()
        obj.check(*self.dependencies)
        return obj


class Museum:
    @dataclass
    class __Museum:

        def check(self, f: float, p: Painter.painter_type) -> None:
            if type(self) not in Museum.possible_types(f, p):
                raise TypeError('Non-compliance with type dependencies')

    museum_type = __Museum

    @classmethod
    def possible_types(cls, f: float, p: Painter.painter_type) -> set[type]:
        return {}

    def __init__(self, f: float, p: Painter.painter_type) -> None:
        p_deps = (2 * f / 10 - 4, Color._Color__Green(12), )
        p.check(*p_deps)

        self.dependencies = (f, p, )

    def construct(self) -> __Museum:
        obj = self.__Museum()
        obj.check(*self.dependencies)
        return obj

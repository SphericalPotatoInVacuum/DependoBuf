# This file was automatically generated by DependoBuf.
# Please do not change it.

from __future__ import annotations

from annotated_types import Ge
from dataclasses import dataclass
from typing import Annotated

Unsigned = Annotated[int, Ge(0)]


class Color:
    @dataclass
    class __Red:
        r: int

        def check(self, s: str) -> None:
            if type(self) not in Color.possible_types(s):
                raise TypeError('Non-compliance with type dependencies')
    @dataclass
    class __Green:
        g: int

        def check(self, s: str) -> None:
            if type(self) not in Color.possible_types(s):
                raise TypeError('Non-compliance with type dependencies')

    color_type = __Red | __Green
    __s_deps = []

    @classmethod
    def possible_types(cls, s: str) -> set[type]:
        return {}

    def __init__(self, s: str) -> None:
        self.dependencies = (s)

    def red(self, r: int) -> __Red:
        obj = self.__Red(r)
        obj.check(*self.dependencies)
        return obj

    def green(self, g: int) -> __Green:
        obj = self.__Green(g)
        obj.check(*self.dependencies)
        return obj


class Moo:
    @dataclass
    class __Moo:

        def check(self, x: int, u: Unsigned, f: float, b: bool, s: str) -> None:
            if type(self) not in Moo.possible_types(x, u, f, b, s):
                raise TypeError('Non-compliance with type dependencies')

    moo_type = __Moo
    __x_deps = []
    __u_deps = []
    __f_deps = []
    __b_deps = []
    __s_deps = []

    @classmethod
    def possible_types(cls, x: int, u: Unsigned, f: float, b: bool, s: str) -> set[type]:
        return {}

    def __init__(self, x: int, u: Unsigned, f: float, b: bool, s: str) -> None:
        self.dependencies = (x, u, f, b, s)

    def construct(self) -> __Moo:
        obj = self.__Moo()
        obj.check(*self.dependencies)
        return obj


class Foo:
    @dataclass
    class __Foo:

        def check(self, m: Moo.moo_type) -> None:
            if type(self) not in Foo.possible_types(m):
                raise TypeError('Non-compliance with type dependencies')

    foo_type = __Foo
    __m_deps = []

    @classmethod
    def possible_types(cls, m: Moo.moo_type) -> set[type]:
        return {}

    def __init__(self, m: Moo.moo_type) -> None:
        m.check(*self.__m_deps)
        self.dependencies = (m)

    def construct(self) -> __Foo:
        obj = self.__Foo()
        obj.check(*self.dependencies)
        return obj

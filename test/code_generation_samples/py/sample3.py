# This file was automatically generated by DependoBuf.
# Please do not change it.

from __future__ import annotations

from annotated_types import Ge
from dataclasses import dataclass
from typing import Annotated

Unsigned = Annotated[int, Ge(0)]


class Nat:
    @dataclass
    class __Zero:

        def check(self) -> None:
            if type(self) not in Nat.possible_types():
                raise TypeError('Non-compliance with type dependencies')
    @dataclass
    class __Succ:
        prev: Nat.nat_type

        def check(self) -> None:
            if type(self) not in Nat.possible_types():
                raise TypeError('Non-compliance with type dependencies')

    nat_type = __Zero | __Succ

    @classmethod
    def possible_types(cls) -> set[type]:
        return {}

    def __init__(self) -> None:
        self.dependencies = ()

    def zero(self) -> __Zero:
        obj = self.__Zero()
        obj.check(*self.dependencies)
        return obj

    def succ(self, prev: Nat.nat_type) -> __Succ:
        obj = self.__Succ(prev)
        obj.check(*self.dependencies)
        return obj


class Message3:
    @dataclass
    class __Message3:
        x: int
        y: int

        def check(self, nat: Nat.nat_type) -> None:
            if type(self) not in Message3.possible_types(nat):
                raise TypeError('Non-compliance with type dependencies')

    message3_type = __Message3

    @classmethod
    def possible_types(cls, nat: Nat.nat_type) -> set[type]:
        return {}

    def __init__(self, nat: Nat.nat_type) -> None:
        self.dependencies = (nat)

    def construct(self, x: int, y: int) -> __Message3:
        obj = self.__Message3(x, y)
        obj.check(*self.dependencies)
        return obj


class Message4:
    @dataclass
    class __Message4:
        m3: Message3.message3_type

        def check(self) -> None:
            if type(self) not in Message4.possible_types():
                raise TypeError('Non-compliance with type dependencies')

    message4_type = __Message4

    @classmethod
    def possible_types(cls) -> set[type]:
        return {}

    def __init__(self) -> None:
        self.dependencies = ()

    def construct(self, m3: Message3.message3_type) -> __Message4:
        obj = self.__Message4(m3)
        obj.check(*self.dependencies)
        return obj

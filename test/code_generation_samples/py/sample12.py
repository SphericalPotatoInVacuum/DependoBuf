# This file was automatically generated by DependoBuf.
# Please do not change it.

from __future__ import annotations

from annotated_types import Ge
from dataclasses import dataclass
from typing import Annotated

Unsigned = Annotated[int, Ge(0)]


class DbufError(TypeError):
    pass


class Xert:
    @dataclass
    class __Good:
        name: str

        def check(self, b: bool) -> None:
            if type(self) not in Xert._possible_types(b):
                raise DbufError(
                    'Type Xert.__Good does not match given dependencies.'
                )

    @dataclass
    class __Bad:
        def check(self, b: bool) -> None:
            if type(self) not in Xert._possible_types(b):
                raise DbufError(
                    'Type Xert.__Bad does not match given dependencies.'
                )

    xert_type = __Good | __Bad

    @classmethod
    def _possible_types(cls, b: bool) -> set[type]:
        actual = (b, )
        expected = (True, )
        if _is_consistent(actual, expected):
            return {cls.__Good}

        expected = (False, )
        if _is_consistent(actual, expected):
            return {cls.__Bad}

        return {}

    def __init__(self, b: bool) -> None:
        self.dependencies = (b, )

    def good(self, name: str) -> __Good:
        obj = self.__Good(name)
        obj.check(*self.dependencies)
        return obj

    def bad(self) -> __Bad:
        obj = self.__Bad()
        obj.check(*self.dependencies)
        return obj


class Yog:
    @dataclass
    class __Yog:
        def check(self, n: int) -> None:
            pass

    yog_type = __Yog

    def __init__(self, n: int) -> None:
        self.dependencies = (n, )

    def construct(self) -> __Yog:
        obj = self.__Yog()
        obj.check(*self.dependencies)
        return obj


class SomeMessage:
    @dataclass
    class __SomeMessage:
        x: Xert.xert_type
        y: Yog.yog_type

        def check(self, n: int, b1: bool, b2: bool) -> None:
            x_deps = ((b1 and b2) or (not (not (not (b1 or b2)))), )
            self.x.check(*x_deps)

            y_deps = (n - (3 * 17), )
            self.y.check(*y_deps)

    some_message_type = __SomeMessage

    def __init__(self, n: int, b1: bool, b2: bool) -> None:
        self.dependencies = (n, b1, b2, )

    def construct(self, x: Xert.xert_type, y: Yog.yog_type) -> __SomeMessage:
        obj = self.__SomeMessage(x, y)
        obj.check(*self.dependencies)
        return obj


def _is_consistent(actual: tuple, expected: tuple) -> bool:
    for i in range(len(actual)):
        if expected[i] is None:
            continue

        if actual[i] != expected[i]:
            return False

    return True


val = SomeMessage(10, True, False).construct(Xert(True).good('Eleazar'), Yog(12).construct())
print(val)

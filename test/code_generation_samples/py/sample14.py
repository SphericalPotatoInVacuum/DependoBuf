# This file was automatically generated by DependoBuf.
# Please do not change it.

from __future__ import annotations

from annotated_types import Ge
from dataclasses import dataclass
from typing import Annotated

Unsigned = Annotated[int, Ge(0)]


class DbufError(TypeError):
    pass


class Tert:
    @dataclass
    class __Tert:

        def check(self, n: int) -> None:
            if type(self) not in Tert._possible_types(n):
                raise DbufError(
                    'Type Tert.__Tert does not match given dependencies.'
                )

    tert_type = __Tert

    @classmethod
    def _possible_types(cls, n: int) -> set[type]:
        return {cls.__Tert}

    def __init__(self, n: int) -> None:
        self.dependencies = (n, )

    def construct(self) -> __Tert:
        obj = self.__Tert()
        obj.check(*self.dependencies)
        return obj


class Xert:
    @dataclass
    class __Base:
        val: int

        def check(self) -> None:
            if type(self) not in Xert._possible_types():
                raise DbufError(
                    'Type Xert.__Base does not match given dependencies.'
                )

    @dataclass
    class __Default:
        def check(self) -> None:
            if type(self) not in Xert._possible_types():
                raise DbufError(
                    'Type Xert.__Default does not match given dependencies.'
                )

    xert_type = __Base | __Default

    @classmethod
    def _possible_types(cls) -> set[type]:
        actual = ()
        expected = ()
        if _is_consistent(actual, expected):
            return {cls.__Base, cls.__Default}

        return {}

    def __init__(self) -> None:
        self.dependencies = ()

    def base(self, val: int) -> __Base:
        obj = self.__Base(val)
        obj.check(*self.dependencies)
        return obj

    def default(self) -> __Default:
        obj = self.__Default()
        obj.check(*self.dependencies)
        return obj


class Lalo:
    @dataclass
    class __Leh:
        t: Tert.tert_type

        def check(self, xe: Xert.xert_type) -> None:
            if type(self) not in Lalo._possible_types(xe):
                raise DbufError(
                    'Type Lalo.__Leh does not match given dependencies.'
                )

            t_deps = ((-1), )
            self.t.check(*t_deps)

    @dataclass
    class __Zero:
        def check(self, xe: Xert.xert_type) -> None:
            if type(self) not in Lalo._possible_types(xe):
                raise DbufError(
                    'Type Lalo.__Zero does not match given dependencies.'
                )

    lalo_type = __Leh | __Zero

    @classmethod
    def _possible_types(cls, xe: Xert.xert_type) -> set[type]:
        actual = (xe, )
        expected = (Xert._Xert__Base(v), )
        if _is_consistent(actual, expected):
            return {cls.__Leh}

        expected = (Xert._Xert__Default(), )
        if _is_consistent(actual, expected):
            return {cls.__Zero}

        return {}

    def __init__(self, xe: Xert.xert_type) -> None:
        self.dependencies = (xe, )

    def leh(self, t: Tert.tert_type) -> __Leh:
        obj = self.__Leh(t)
        obj.check(*self.dependencies)
        return obj

    def zero(self) -> __Zero:
        obj = self.__Zero()
        obj.check(*self.dependencies)
        return obj


def _is_consistent(actual: tuple, expected: tuple) -> bool:
    for i in range(len(actual)):
        if expected[i] is None:
            continue

        if actual[i] != expected[i]:
            return False

    return True

# This file was automatically generated by DependoBuf.
# Please do not change it.

from __future__ import annotations

from annotated_types import Ge
from dataclasses import dataclass
from typing import Annotated

Unsigned = Annotated[int, Ge(0)]


class Nat:
    @dataclass
    class __Zero:

        def check(self) -> None:
            if type(self) not in Nat.possible_types():
                raise TypeError('Non-compliance with type dependencies')
    @dataclass
    class __Succ:
        prev: Nat.nat_type

        def check(self) -> None:
            if type(self) not in Nat.possible_types():
                raise TypeError('Non-compliance with type dependencies')

    nat_type = __Zero | __Succ

    @classmethod
    def possible_types(cls) -> set[type]:
        return {cls.__Zero, cls.__Succ}

    def __init__(self) -> None:
        self.dependencies = ()

    def zero(self) -> __Zero:
        obj = self.__Zero()
        obj.check(*self.dependencies)
        return obj

    def succ(self, prev: Nat.nat_type) -> __Succ:
        obj = self.__Succ(prev)
        obj.check(*self.dependencies)
        return obj


class IntList:
    @dataclass
    class __Nil:

        def check(self, size: Nat.nat_type) -> None:
            if type(self) not in IntList.possible_types(size):
                raise TypeError('Non-compliance with type dependencies')
    @dataclass
    class __Base:
        head: int
        tail: IntList.int_list_type

        def check(self, size: Nat.nat_type) -> None:
            if type(self) not in IntList.possible_types(size):
                raise TypeError('Non-compliance with type dependencies')

    int_list_type = __Nil | __Base
    __size_deps = []

    @classmethod
    def possible_types(cls, size: Nat.nat_type) -> set[type]:
        return {cls.__Nil, cls.__Base}

    def __init__(self, size: Nat.nat_type) -> None:
        size.check(*self.__size_deps)

        self.dependencies = (size)

    def nil(self) -> __Nil:
        obj = self.__Nil()
        obj.check(*self.dependencies)
        return obj

    def base(self, head: int, tail: IntList.int_list_type) -> __Base:
        obj = self.__Base(head, tail)
        obj.check(*self.dependencies)
        return obj


nat1 = Nat().zero()
nat2 = Nat().succ(prev=nat1)
nat3 = Nat().succ(prev=nat2)

print()
print(nat3)
print()
# This file was automatically generated by DependoBuf.
# Please do not change it.

from __future__ import annotations

from annotated_types import Ge
from dataclasses import dataclass
from typing import Annotated

Unsigned = Annotated[int, Ge(0)]


class DbufError(TypeError):
    pass


class Nat:
    @dataclass
    class __Zero:
        def check(self) -> None:
            if type(self) not in Nat._possible_types():
                raise DbufError(
                    'Type Nat.__Zero does not match given dependencies.'
                )

    @dataclass
    class __Succ:
        prev: Nat.nat_type

        def check(self) -> None:
            if type(self) not in Nat._possible_types():
                raise DbufError(
                    'Type Nat.__Succ does not match given dependencies.'
                )

    nat_type = __Zero | __Succ

    @classmethod
    def _possible_types(cls) -> set[type]:
        actual = ()
        expected = ()
        if _is_consistent(actual, expected):
            return {cls.__Zero, cls.__Succ}

        return {}

    def __init__(self) -> None:
        self.dependencies = ()

    def zero(self) -> __Zero:
        obj = self.__Zero()
        obj.check(*self.dependencies)
        return obj

    def succ(self, prev: Nat.nat_type) -> __Succ:
        obj = self.__Succ(prev)
        obj.check(*self.dependencies)
        return obj


class SomeMessage:
    @dataclass
    class __SomeMessage:
        x: int
        y: int

        def check(self, nat: Nat.nat_type) -> None:
            pass

    some_message_type = __SomeMessage

    def __init__(self, nat: Nat.nat_type) -> None:
        self.dependencies = (nat, )

    def construct(self, x: int, y: int) -> __SomeMessage:
        obj = self.__SomeMessage(x, y)
        obj.check(*self.dependencies)
        return obj


class AnotherMessage:
    @dataclass
    class __AnotherMessage:
        sm: SomeMessage.some_message_type

        def check(self) -> None:
            sm_deps = (Nat._Nat__Zero(), )
            self.sm.check(*sm_deps)

    another_message_type = __AnotherMessage

    def __init__(self) -> None:
        self.dependencies = ()

    def construct(self, sm: SomeMessage.some_message_type) -> __AnotherMessage:
        obj = self.__AnotherMessage(sm)
        obj.check(*self.dependencies)
        return obj


def _is_consistent(actual: tuple, expected: tuple) -> bool:
    for i in range(len(actual)):
        if expected[i] is None:
            continue

        if actual[i] != expected[i]:
            return False

    return True

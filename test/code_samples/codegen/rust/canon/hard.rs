#![allow(unused_variables, unused_imports, unused_parens, dead_code)]
//! This file was automatically generated by DependoBuf

pub struct C {
    pub field: std::rc::Rc<B>,
}

pub enum TestSubstitution {
    ListOfLengthTen{
        arr: std::rc::Rc<List>,
    },
    ListOfLengthN{
        arr: std::rc::Rc<List>,
    },
}
use TestSubstitution::*;

pub enum B {
    BCons{
        list: std::rc::Rc<List>,
    },
}
use B::*;

pub struct A {
    pub list: std::rc::Rc<List>,
}

pub enum List {
    ListEnd,
    ListNode{
        value: i64,
        tail: std::rc::Rc<List>,
    },
}
use List::*;

impl C {
    pub fn check(&self, n: i64, m: i64, a: &std::rc::Rc<A>) -> bool {
        let field = &self.field;
        if !field.check(n, m, &std::rc::Rc::new(A { list: (a.list).clone() })) { return false; }
        return true;
    }
}

impl TestSubstitution {
    pub fn check(&self, n: i64, m: i64) -> bool {
        match self {
            ListOfLengthTen { arr } => {
                if !arr.check((n + m)) { return false; }
            }
            ListOfLengthN { arr } => {
                if !arr.check(n) { return false; }
            }
        }
        return true;
    }
}

impl B {
    pub fn check(&self, n: i64, m: i64, a: &std::rc::Rc<A>) -> bool {
        match self {
            BCons { list } => {
                if !list.check((n + m)) { return false; }
            }
        }
        return true;
    }
}

impl A {
    pub fn check(&self, n: i64, m: i64) -> bool {
        let list = &self.list;
        if !list.check(-(n + m)) { return false; }
        return true;
    }
}

impl List {
    pub fn check(&self, n: i64) -> bool {
        match self {
            ListEnd {  } => {
            }
            ListNode { value, tail } => {
                if !tail.check((n - 1)) { return false; }
            }
        }
        return true;
    }
}


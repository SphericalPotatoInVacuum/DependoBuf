#![allow(unused_variables, unused_imports, unused_parens, dead_code)]
//! This file was automatically generated by DependoBuf

pub struct Kek {
    pub c: i64,
}

pub struct Foo {
}

pub struct Lol {
    pub d: std::rc::Rc<Pop>,
    pub e: std::rc::Rc<Foo>,
    pub g: std::rc::Rc<Kek>,
}

pub enum B {
    BCons{
        field: i64,
    },
}
use B::*;

pub struct D {
    pub b: std::rc::Rc<B>,
    pub c: std::rc::Rc<C>,
}

pub struct C {
    pub c: i64,
}

pub struct Pop {
    pub a: i64,
}

pub struct A {
    pub a: i64,
    pub b: i64,
}

impl Kek {
    pub fn check(&self, k: &std::rc::Rc<Pop>, f: &std::rc::Rc<Foo>) -> bool {
        let c = self.c;
        return true;
    }
}

impl Foo {
    pub fn check(&self, p: &std::rc::Rc<Pop>) -> bool {
        return true;
    }
}

impl Lol {
    pub fn check(&self) -> bool {
        let d = &self.d;
        let e = &self.e;
        let g = &self.g;
        if !d.check() { return false; }
        if !e.check(&d) { return false; }
        if !g.check(&d, &e) { return false; }
        return true;
    }
}

impl B {
    pub fn check(&self, a: &std::rc::Rc<A>) -> bool {
        match self {
            BCons { field } => {
            }
        }
        return true;
    }
}

impl D {
    pub fn check(&self) -> bool {
        let b = &self.b;
        let c = &self.c;
        if !b.check(&std::rc::Rc::new(A { a: (5).clone(), b: (6).clone() })) { return false; }
        if !c.check(&b) { return false; }
        return true;
    }
}

impl C {
    pub fn check(&self, b: &std::rc::Rc<B>) -> bool {
        let c = self.c;
        return true;
    }
}

impl Pop {
    pub fn check(&self) -> bool {
        let a = self.a;
        return true;
    }
}

impl A {
    pub fn check(&self) -> bool {
        let a = self.a;
        let b = self.b;
        return true;
    }
}


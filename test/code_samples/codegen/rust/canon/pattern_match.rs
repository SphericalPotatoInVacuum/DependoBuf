#![allow(unused_variables, unused_imports, unused_parens, dead_code)]
//! This file was automatically generated by DependoBuf

pub struct K {
    pub j: std::rc::Rc<J>,
}

pub enum I {
    ICons{
        intField: i64,
    },
}
use I::*;

pub struct G {
}

pub enum F {
    FCons{
        intField: i64,
    },
    FCons2{
        intField: i64,
    },
}
use F::*;

pub struct J {
}

pub struct E {
    pub dField: std::rc::Rc<D>,
    pub boolField: bool,
}

pub struct B {
}

pub struct D {
    pub intField: i64,
    pub stringField: std::rc::Rc<String>,
}

pub struct H {
    pub g: std::rc::Rc<G>,
}

pub struct C {
    pub field: std::rc::Rc<B>,
}

pub enum A {
    Cons{
        intField: i64,
    },
    Nil,
}
use A::*;

impl K {
    pub fn check(&self) -> bool {
        let j = &self.j;
        if !j.check(&std::rc::Rc::new(ICons { intField: (10).clone() })) { return false; }
        return true;
    }
}

impl I {
    pub fn check(&self, d: &std::rc::Rc<D>) -> bool {
        match self {
            ICons { intField } => {
            }
        }
        return true;
    }
}

impl G {
    pub fn check(&self, f: &std::rc::Rc<F>) -> bool {
        return true;
    }
}

impl F {
    pub fn check(&self, e: &std::rc::Rc<E>) -> bool {
        match self {
            FCons { intField } => {
            }
            FCons2 { intField } => {
            }
        }
        return true;
    }
}

impl J {
    pub fn check(&self, i: &std::rc::Rc<I>) -> bool {
        return true;
    }
}

impl E {
    pub fn check(&self) -> bool {
        let dField = &self.dField;
        let boolField = self.boolField;
        if !dField.check() { return false; }
        return true;
    }
}

impl B {
    pub fn check(&self, a: &std::rc::Rc<A>) -> bool {
        return true;
    }
}

impl D {
    pub fn check(&self) -> bool {
        let intField = self.intField;
        let stringField = &self.stringField;
        return true;
    }
}

impl H {
    pub fn check(&self) -> bool {
        let g = &self.g;
        if !g.check(&std::rc::Rc::new(FCons2 { intField: (10).clone() })) { return false; }
        return true;
    }
}

impl C {
    pub fn check(&self) -> bool {
        let field = &self.field;
        if !field.check(&std::rc::Rc::new(Cons { intField: (10).clone() })) { return false; }
        return true;
    }
}

impl A {
    pub fn check(&self, n: i64) -> bool {
        match self {
            Cons { intField } => {
            }
            Nil {  } => {
            }
        }
        return true;
    }
}


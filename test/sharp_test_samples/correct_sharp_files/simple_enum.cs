// This file was automatically generated by DependoBuf.
// Please do not change it.

using System;
using System.Collections.Generic;

class dbuf {

public class First {
	public int a1;
	public bool b1;

	public First() {
	}

	public bool Check() {
		return true;
	}
}

public class Second {
	public bool a2;
	public int b2;

	public Second() {
	}

	public bool Check() {
		return true;
	}
}

public class Independent {
	dynamic value;

	public Independent() {
	}
	public bool Check() {
		return false || (value is First) && value.Check() || (value is Second) && value.Check();
	}
}

public class Dependencies {
	public readonly Independent i;

	public Dependencies(Independent i_) {
		i = i_;
	}

	public bool Check() {
		return true;
	}
}

public class A {
	public readonly int a;
	public int a1;

	public A(int a_) {
		a = a_;
	}

	public bool Check() {
		return true;
	}
}

public class B {
	public readonly int a;
	public bool a2;

	public B(int a_) {
		a = a_;
	}

	public bool Check() {
		return true;
	}
}

public class Dependent_A_B {
	private readonly bool IsConstructable;
	public readonly Type[] Restrictions = {typeof(A), typeof(B)};

	public Dependent_A_B(int a_) {
		IsConstructable = true && a_ == 5 && a_ == 5;
	}
	public bool Check() {
		return IsConstructable;
	}
}

public class C {
	public readonly int a;
	public string a3;

	public C(int a_) {
		a = a_;
	}

	public bool Check() {
		return true;
	}
}

public class Dependent_C {
	private readonly bool IsConstructable;
	public readonly Type[] Restrictions = {typeof(C)};

	public Dependent_C(int a_) {
		IsConstructable = true && a_ == 3;
	}
	public bool Check() {
		return IsConstructable;
	}
}

public class Dependent {
	private readonly Type[] AllowedTypes = {typeof(Dependent_A_B), typeof(Dependent_C)};
	private readonly List<Type> Restrictions;
	private dynamic _value;

	public dynamic Value {
		get { return _value; }
		set {
			foreach (var type in Restrictions) {
				if (type.IsInstanceOfType(value)) {
					_value = value;
					return;
				}
			}
			throw new ArgumentException("Incorrect argument type");
		}
	}


	public Dependent(int a_) {
		Restrictions = new List<Type>();
		foreach (var type in AllowedTypes) {
			var val = (dynamic)Activator.CreateInstance(type, a_);
			if (val.Check()) {
				foreach (var restr in val.restrictions) {
					Restrictions.Add(restr);
				}
			}
		}

	}
	public bool Check() {
		foreach (var type in Restrictions) {
			if (type.IsInstanceOfType(_value)) {
				if (type.GetMethod("Check") != null) {
					return _value.Check();
				} else {
					return true;
				}
			}
		}
		return false;
	}

}

public class Fields {
	public readonly int a;
	public Independent i;
	public Dependent d;

	public Fields(int a_) {
		a = a_;
		d = new Dependent(a);
	}

	public bool Check() {
		return true;
	}
}

}


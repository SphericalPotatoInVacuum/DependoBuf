In file included from /usr/include/c++/11/bits/move.h:57,
                 from /usr/include/c++/11/bits/stl_pair.h:59,
                 from /usr/include/c++/11/bits/stl_algobase.h:64,
                 from /usr/include/c++/11/memory:63,
                 from src/parser/expression.h:3,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_default_constructible<dbuf::parser::BinaryExpression>’:
/usr/include/c++/11/type_traits:3176:36:   required from ‘constexpr const bool std::is_default_constructible_v<dbuf::parser::BinaryExpression>’
/usr/include/c++/11/variant:308:4:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_default_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:964:52: error: static assertion failed: template argument must be a complete class or an unbounded array
  964 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:964:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::BinaryExpression> >((std::__type_identity<dbuf::parser::BinaryExpression>{}, std::__type_identity<dbuf::parser::BinaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_copy_constructible<dbuf::parser::BinaryExpression>’:
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<dbuf::parser::BinaryExpression>’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:987:52: error: static assertion failed: template argument must be a complete class or an unbounded array
  987 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:987:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::BinaryExpression> >((std::__type_identity<dbuf::parser::BinaryExpression>{}, std::__type_identity<dbuf::parser::BinaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_copy_constructible<dbuf::parser::UnaryExpression>’:
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<dbuf::parser::UnaryExpression>’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:987:52: error: static assertion failed: template argument must be a complete class or an unbounded array
/usr/include/c++/11/type_traits:987:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::UnaryExpression> >((std::__type_identity<dbuf::parser::UnaryExpression>{}, std::__type_identity<dbuf::parser::UnaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_copy_constructible<dbuf::parser::ConstructedValue>’:
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/type_traits:946:30:   required from ‘struct std::__is_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, const std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>&>’
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:987:52: error: static assertion failed: template argument must be a complete class or an unbounded array
/usr/include/c++/11/type_traits:987:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::ConstructedValue> >((std::__type_identity<dbuf::parser::ConstructedValue>{}, std::__type_identity<dbuf::parser::ConstructedValue>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_copy_assignable<dbuf::parser::ConstructedValue>’:
/usr/include/c++/11/type_traits:3186:73:   required from ‘constexpr const bool std::is_copy_assignable_v<dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:315:8:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_copy_assign’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/type_traits:946:30:   required from ‘struct std::__is_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, const std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>&>’
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1110:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1110 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1110:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::ConstructedValue> >((std::__type_identity<dbuf::parser::ConstructedValue>{}, std::__type_identity<dbuf::parser::ConstructedValue>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_move_constructible<dbuf::parser::ConstructedValue>’:
/usr/include/c++/11/type_traits:3182:33:   required from ‘constexpr const bool std::is_move_constructible_v<dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:312:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_move_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/type_traits:946:30:   required from ‘struct std::__is_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, const std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>&>’
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1010:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1010 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1010:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::ConstructedValue> >((std::__type_identity<dbuf::parser::ConstructedValue>{}, std::__type_identity<dbuf::parser::ConstructedValue>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_move_assignable<dbuf::parser::ConstructedValue>’:
/usr/include/c++/11/type_traits:3188:73:   required from ‘constexpr const bool std::is_move_assignable_v<dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:318:8:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_move_assign’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/type_traits:946:30:   required from ‘struct std::__is_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, const std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>&>’
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1131:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1131 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1131:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::ConstructedValue> >((std::__type_identity<dbuf::parser::ConstructedValue>{}, std::__type_identity<dbuf::parser::ConstructedValue>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_trivially_destructible<dbuf::parser::ConstructedValue>’:
/usr/include/c++/11/type_traits:3214:37:   required from ‘constexpr const bool std::is_trivially_destructible_v<dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:321:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_dtor’
/usr/include/c++/11/variant:330:4:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:1343:11:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1339:37: error: invalid use of incomplete type ‘struct dbuf::parser::ConstructedValue’
 1339 |                     __bool_constant<__has_trivial_destructor(_Tp)>>
      |                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from src/parser/expression.cc:1:
src/parser/expression.h:11:8: note: forward declaration of ‘struct dbuf::parser::ConstructedValue’
   11 | struct ConstructedValue;
      |        ^~~~~~~~~~~~~~~~
In file included from /usr/include/c++/11/bits/move.h:57,
                 from /usr/include/c++/11/bits/stl_pair.h:59,
                 from /usr/include/c++/11/bits/stl_algobase.h:64,
                 from /usr/include/c++/11/memory:63,
                 from src/parser/expression.h:3,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/type_traits:1341:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1341 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1341:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::ConstructedValue> >((std::__type_identity<dbuf::parser::ConstructedValue>{}, std::__type_identity<dbuf::parser::ConstructedValue>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘constexpr const bool std::is_trivially_destructible_v<dbuf::parser::ConstructedValue>’:
/usr/include/c++/11/variant:321:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_dtor’
/usr/include/c++/11/variant:330:4:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:1343:11:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:3214:37: error: ‘value’ is not a member of ‘std::is_trivially_destructible<dbuf::parser::ConstructedValue>’
 3214 |     is_trivially_destructible<_Tp>::value;
      |                                     ^~~~~
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::__is_trivially_move_constructible_impl<dbuf::parser::ConstructedValue, true>’:
/usr/include/c++/11/type_traits:1277:12:   required from ‘struct std::is_trivially_move_constructible<dbuf::parser::ConstructedValue>’
/usr/include/c++/11/type_traits:3202:43:   required from ‘constexpr const bool std::is_trivially_move_constructible_v<dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:325:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_move_ctor’
/usr/include/c++/11/variant:330:23:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue}]’
/usr/include/c++/11/variant:714:12:   [ skipping 3 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1272:25: error: invalid use of incomplete type ‘struct dbuf::parser::ConstructedValue’
 1272 |                         __is_trivially_constructible(_Tp, _Tp&&)>>
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from src/parser/expression.cc:1:
src/parser/expression.h:11:8: note: forward declaration of ‘struct dbuf::parser::ConstructedValue’
   11 | struct ConstructedValue;
      |        ^~~~~~~~~~~~~~~~
In file included from /usr/include/c++/11/bits/move.h:57,
                 from /usr/include/c++/11/bits/stl_pair.h:59,
                 from /usr/include/c++/11/bits/stl_algobase.h:64,
                 from /usr/include/c++/11/memory:63,
                 from src/parser/expression.h:3,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_trivially_move_constructible<dbuf::parser::ConstructedValue>’:
/usr/include/c++/11/type_traits:3202:43:   required from ‘constexpr const bool std::is_trivially_move_constructible_v<dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:325:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_move_ctor’
/usr/include/c++/11/variant:330:23:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:1343:11:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1280:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1280 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1280:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::ConstructedValue> >((std::__type_identity<dbuf::parser::ConstructedValue>{}, std::__type_identity<dbuf::parser::ConstructedValue>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘constexpr const bool std::is_trivially_move_constructible_v<dbuf::parser::ConstructedValue>’:
/usr/include/c++/11/variant:325:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_move_ctor’
/usr/include/c++/11/variant:330:23:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:1343:11:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:3202:43: error: ‘value’ is not a member of ‘std::is_trivially_move_constructible<dbuf::parser::ConstructedValue>’
 3202 |     is_trivially_move_constructible<_Tp>::value;
      |                                           ^~~~~
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_trivially_move_assignable<dbuf::parser::ConstructedValue>’:
/usr/include/c++/11/type_traits:3211:40:   required from ‘constexpr const bool std::is_trivially_move_assignable_v<dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:331:8:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:1343:11:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1331:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1331 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1331:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::ConstructedValue> >((std::__type_identity<dbuf::parser::ConstructedValue>{}, std::__type_identity<dbuf::parser::ConstructedValue>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::__is_trivially_copy_constructible_impl<dbuf::parser::ConstructedValue, true>’:
/usr/include/c++/11/type_traits:1254:12:   required from ‘struct std::is_trivially_copy_constructible<dbuf::parser::ConstructedValue>’
/usr/include/c++/11/type_traits:3199:43:   required from ‘constexpr const bool std::is_trivially_copy_constructible_v<dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:323:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_copy_ctor’
/usr/include/c++/11/variant:327:23:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_copy_assign’
/usr/include/c++/11/variant:667:11:   required by substitution of ‘template<class ... _Types> using _Copy_assign_alias = std::__detail::__variant::_Copy_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_copy_assign, _Types ...> [with _Types = {dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue}]’
/usr/include/c++/11/variant:671:12:   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1249:25: error: invalid use of incomplete type ‘struct dbuf::parser::ConstructedValue’
 1249 |                         __is_trivially_constructible(_Tp, const _Tp&)>>
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from src/parser/expression.cc:1:
src/parser/expression.h:11:8: note: forward declaration of ‘struct dbuf::parser::ConstructedValue’
   11 | struct ConstructedValue;
      |        ^~~~~~~~~~~~~~~~
In file included from /usr/include/c++/11/bits/move.h:57,
                 from /usr/include/c++/11/bits/stl_pair.h:59,
                 from /usr/include/c++/11/bits/stl_algobase.h:64,
                 from /usr/include/c++/11/memory:63,
                 from src/parser/expression.h:3,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_trivially_copy_constructible<dbuf::parser::ConstructedValue>’:
/usr/include/c++/11/type_traits:3199:43:   required from ‘constexpr const bool std::is_trivially_copy_constructible_v<dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:323:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_copy_ctor’
/usr/include/c++/11/variant:327:23:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_copy_assign’
/usr/include/c++/11/variant:667:11:   required by substitution of ‘template<class ... _Types> using _Copy_assign_alias = std::__detail::__variant::_Copy_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_copy_assign, _Types ...> [with _Types = {dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue}]’
/usr/include/c++/11/variant:671:12:   required from ‘struct std::__detail::__variant::_Move_assign_base<false, dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:714:12:   [ skipping 3 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1257:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1257 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1257:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::ConstructedValue> >((std::__type_identity<dbuf::parser::ConstructedValue>{}, std::__type_identity<dbuf::parser::ConstructedValue>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘constexpr const bool std::is_trivially_copy_constructible_v<dbuf::parser::ConstructedValue>’:
/usr/include/c++/11/variant:323:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_copy_ctor’
/usr/include/c++/11/variant:327:23:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_copy_assign’
/usr/include/c++/11/variant:667:11:   required by substitution of ‘template<class ... _Types> using _Copy_assign_alias = std::__detail::__variant::_Copy_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_copy_assign, _Types ...> [with _Types = {dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue}]’
/usr/include/c++/11/variant:671:12:   required from ‘struct std::__detail::__variant::_Move_assign_base<false, dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:1343:11:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:3199:43: error: ‘value’ is not a member of ‘std::is_trivially_copy_constructible<dbuf::parser::ConstructedValue>’
 3199 |     is_trivially_copy_constructible<_Tp>::value;
      |                                           ^~~~~
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_trivially_copy_assignable<dbuf::parser::ConstructedValue>’:
/usr/include/c++/11/type_traits:3208:40:   required from ‘constexpr const bool std::is_trivially_copy_assignable_v<dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:328:8:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>::_S_trivial_copy_assign’
/usr/include/c++/11/variant:667:11:   required by substitution of ‘template<class ... _Types> using _Copy_assign_alias = std::__detail::__variant::_Copy_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_copy_assign, _Types ...> [with _Types = {dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue}]’
/usr/include/c++/11/variant:671:12:   required from ‘struct std::__detail::__variant::_Move_assign_base<false, dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>’
/usr/include/c++/11/variant:1343:11:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/include/c++/11/type_traits:977:12:   required from ‘struct std::__is_copy_constructible_impl<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, true>’
/usr/include/c++/11/type_traits:984:12:   required from ‘struct std::is_copy_constructible<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/type_traits:3179:33:   required from ‘constexpr const bool std::is_copy_constructible_v<std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue> >’
/usr/include/c++/11/variant:310:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1310:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1310 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1310:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::ConstructedValue> >((std::__type_identity<dbuf::parser::ConstructedValue>{}, std::__type_identity<dbuf::parser::ConstructedValue>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_copy_assignable<dbuf::parser::BinaryExpression>’:
/usr/include/c++/11/type_traits:3186:73:   required from ‘constexpr const bool std::is_copy_assignable_v<dbuf::parser::BinaryExpression>’
/usr/include/c++/11/variant:315:8:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_assign’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1110:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1110 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1110:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::BinaryExpression> >((std::__type_identity<dbuf::parser::BinaryExpression>{}, std::__type_identity<dbuf::parser::BinaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_copy_assignable<dbuf::parser::UnaryExpression>’:
/usr/include/c++/11/type_traits:3186:73:   required from ‘constexpr const bool std::is_copy_assignable_v<dbuf::parser::UnaryExpression>’
/usr/include/c++/11/variant:315:8:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_copy_assign’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1110:52: error: static assertion failed: template argument must be a complete class or an unbounded array
/usr/include/c++/11/type_traits:1110:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::UnaryExpression> >((std::__type_identity<dbuf::parser::UnaryExpression>{}, std::__type_identity<dbuf::parser::UnaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_move_constructible<dbuf::parser::BinaryExpression>’:
/usr/include/c++/11/type_traits:3182:33:   required from ‘constexpr const bool std::is_move_constructible_v<dbuf::parser::BinaryExpression>’
/usr/include/c++/11/variant:312:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_move_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1010:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1010 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1010:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::BinaryExpression> >((std::__type_identity<dbuf::parser::BinaryExpression>{}, std::__type_identity<dbuf::parser::BinaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_move_constructible<dbuf::parser::UnaryExpression>’:
/usr/include/c++/11/type_traits:3182:33:   required from ‘constexpr const bool std::is_move_constructible_v<dbuf::parser::UnaryExpression>’
/usr/include/c++/11/variant:312:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_move_ctor’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1010:52: error: static assertion failed: template argument must be a complete class or an unbounded array
/usr/include/c++/11/type_traits:1010:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::UnaryExpression> >((std::__type_identity<dbuf::parser::UnaryExpression>{}, std::__type_identity<dbuf::parser::UnaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_move_assignable<dbuf::parser::BinaryExpression>’:
/usr/include/c++/11/type_traits:3188:73:   required from ‘constexpr const bool std::is_move_assignable_v<dbuf::parser::BinaryExpression>’
/usr/include/c++/11/variant:318:8:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_move_assign’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1131:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1131 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1131:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::BinaryExpression> >((std::__type_identity<dbuf::parser::BinaryExpression>{}, std::__type_identity<dbuf::parser::BinaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_move_assignable<dbuf::parser::UnaryExpression>’:
/usr/include/c++/11/type_traits:3188:73:   required from ‘constexpr const bool std::is_move_assignable_v<dbuf::parser::UnaryExpression>’
/usr/include/c++/11/variant:318:8:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_move_assign’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1131:52: error: static assertion failed: template argument must be a complete class or an unbounded array
/usr/include/c++/11/type_traits:1131:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::UnaryExpression> >((std::__type_identity<dbuf::parser::UnaryExpression>{}, std::__type_identity<dbuf::parser::UnaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_trivially_destructible<dbuf::parser::BinaryExpression>’:
/usr/include/c++/11/type_traits:3214:37:   required from ‘constexpr const bool std::is_trivially_destructible_v<dbuf::parser::BinaryExpression>’
/usr/include/c++/11/variant:321:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_dtor’
/usr/include/c++/11/variant:330:4:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1339:37: error: invalid use of incomplete type ‘struct dbuf::parser::BinaryExpression’
 1339 |                     __bool_constant<__has_trivial_destructor(_Tp)>>
      |                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from src/parser/expression.cc:1:
src/parser/expression.h:51:8: note: forward declaration of ‘struct dbuf::parser::BinaryExpression’
   51 | struct BinaryExpression {
      |        ^~~~~~~~~~~~~~~~
In file included from /usr/include/c++/11/bits/move.h:57,
                 from /usr/include/c++/11/bits/stl_pair.h:59,
                 from /usr/include/c++/11/bits/stl_algobase.h:64,
                 from /usr/include/c++/11/memory:63,
                 from src/parser/expression.h:3,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/type_traits:1341:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1341 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1341:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::BinaryExpression> >((std::__type_identity<dbuf::parser::BinaryExpression>{}, std::__type_identity<dbuf::parser::BinaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘constexpr const bool std::is_trivially_destructible_v<dbuf::parser::BinaryExpression>’:
/usr/include/c++/11/variant:321:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_dtor’
/usr/include/c++/11/variant:330:4:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:3214:37: error: ‘value’ is not a member of ‘std::is_trivially_destructible<dbuf::parser::BinaryExpression>’
 3214 |     is_trivially_destructible<_Tp>::value;
      |                                     ^~~~~
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_trivially_destructible<dbuf::parser::UnaryExpression>’:
/usr/include/c++/11/type_traits:3214:37:   required from ‘constexpr const bool std::is_trivially_destructible_v<dbuf::parser::UnaryExpression>’
/usr/include/c++/11/variant:321:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_dtor’
/usr/include/c++/11/variant:330:4:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1339:37: error: invalid use of incomplete type ‘struct dbuf::parser::UnaryExpression’
 1339 |                     __bool_constant<__has_trivial_destructor(_Tp)>>
      |                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from src/parser/expression.cc:1:
src/parser/expression.h:35:8: note: forward declaration of ‘struct dbuf::parser::UnaryExpression’
   35 | struct UnaryExpression;
      |        ^~~~~~~~~~~~~~~
In file included from /usr/include/c++/11/bits/move.h:57,
                 from /usr/include/c++/11/bits/stl_pair.h:59,
                 from /usr/include/c++/11/bits/stl_algobase.h:64,
                 from /usr/include/c++/11/memory:63,
                 from src/parser/expression.h:3,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/type_traits:1341:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1341 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1341:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::UnaryExpression> >((std::__type_identity<dbuf::parser::UnaryExpression>{}, std::__type_identity<dbuf::parser::UnaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘constexpr const bool std::is_trivially_destructible_v<dbuf::parser::UnaryExpression>’:
/usr/include/c++/11/variant:321:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_dtor’
/usr/include/c++/11/variant:330:4:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:3214:37: error: ‘value’ is not a member of ‘std::is_trivially_destructible<dbuf::parser::UnaryExpression>’
 3214 |     is_trivially_destructible<_Tp>::value;
      |                                     ^~~~~
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::__is_trivially_move_constructible_impl<dbuf::parser::BinaryExpression, true>’:
/usr/include/c++/11/type_traits:1277:12:   required from ‘struct std::is_trivially_move_constructible<dbuf::parser::BinaryExpression>’
/usr/include/c++/11/type_traits:3202:43:   required from ‘constexpr const bool std::is_trivially_move_constructible_v<dbuf::parser::BinaryExpression>’
/usr/include/c++/11/variant:325:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_ctor’
/usr/include/c++/11/variant:330:23:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1272:25: error: invalid use of incomplete type ‘struct dbuf::parser::BinaryExpression’
 1272 |                         __is_trivially_constructible(_Tp, _Tp&&)>>
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from src/parser/expression.cc:1:
src/parser/expression.h:51:8: note: forward declaration of ‘struct dbuf::parser::BinaryExpression’
   51 | struct BinaryExpression {
      |        ^~~~~~~~~~~~~~~~
In file included from /usr/include/c++/11/bits/move.h:57,
                 from /usr/include/c++/11/bits/stl_pair.h:59,
                 from /usr/include/c++/11/bits/stl_algobase.h:64,
                 from /usr/include/c++/11/memory:63,
                 from src/parser/expression.h:3,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_trivially_move_constructible<dbuf::parser::BinaryExpression>’:
/usr/include/c++/11/type_traits:3202:43:   required from ‘constexpr const bool std::is_trivially_move_constructible_v<dbuf::parser::BinaryExpression>’
/usr/include/c++/11/variant:325:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_ctor’
/usr/include/c++/11/variant:330:23:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1280:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1280 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1280:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::BinaryExpression> >((std::__type_identity<dbuf::parser::BinaryExpression>{}, std::__type_identity<dbuf::parser::BinaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘constexpr const bool std::is_trivially_move_constructible_v<dbuf::parser::BinaryExpression>’:
/usr/include/c++/11/variant:325:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_ctor’
/usr/include/c++/11/variant:330:23:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:3202:43: error: ‘value’ is not a member of ‘std::is_trivially_move_constructible<dbuf::parser::BinaryExpression>’
 3202 |     is_trivially_move_constructible<_Tp>::value;
      |                                           ^~~~~
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::__is_trivially_move_constructible_impl<dbuf::parser::UnaryExpression, true>’:
/usr/include/c++/11/type_traits:1277:12:   required from ‘struct std::is_trivially_move_constructible<dbuf::parser::UnaryExpression>’
/usr/include/c++/11/type_traits:3202:43:   required from ‘constexpr const bool std::is_trivially_move_constructible_v<dbuf::parser::UnaryExpression>’
/usr/include/c++/11/variant:325:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_ctor’
/usr/include/c++/11/variant:330:23:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1272:25: error: invalid use of incomplete type ‘struct dbuf::parser::UnaryExpression’
 1272 |                         __is_trivially_constructible(_Tp, _Tp&&)>>
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from src/parser/expression.cc:1:
src/parser/expression.h:35:8: note: forward declaration of ‘struct dbuf::parser::UnaryExpression’
   35 | struct UnaryExpression;
      |        ^~~~~~~~~~~~~~~
In file included from /usr/include/c++/11/bits/move.h:57,
                 from /usr/include/c++/11/bits/stl_pair.h:59,
                 from /usr/include/c++/11/bits/stl_algobase.h:64,
                 from /usr/include/c++/11/memory:63,
                 from src/parser/expression.h:3,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_trivially_move_constructible<dbuf::parser::UnaryExpression>’:
/usr/include/c++/11/type_traits:3202:43:   required from ‘constexpr const bool std::is_trivially_move_constructible_v<dbuf::parser::UnaryExpression>’
/usr/include/c++/11/variant:325:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_ctor’
/usr/include/c++/11/variant:330:23:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1280:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1280 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1280:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::UnaryExpression> >((std::__type_identity<dbuf::parser::UnaryExpression>{}, std::__type_identity<dbuf::parser::UnaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘constexpr const bool std::is_trivially_move_constructible_v<dbuf::parser::UnaryExpression>’:
/usr/include/c++/11/variant:325:5:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_ctor’
/usr/include/c++/11/variant:330:23:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:3202:43: error: ‘value’ is not a member of ‘std::is_trivially_move_constructible<dbuf::parser::UnaryExpression>’
 3202 |     is_trivially_move_constructible<_Tp>::value;
      |                                           ^~~~~
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_trivially_move_assignable<dbuf::parser::BinaryExpression>’:
/usr/include/c++/11/type_traits:3211:40:   required from ‘constexpr const bool std::is_trivially_move_assignable_v<dbuf::parser::BinaryExpression>’
/usr/include/c++/11/variant:331:8:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1331:52: error: static assertion failed: template argument must be a complete class or an unbounded array
 1331 |       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/type_traits:1331:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::BinaryExpression> >((std::__type_identity<dbuf::parser::BinaryExpression>{}, std::__type_identity<dbuf::parser::BinaryExpression>()))’ evaluates to false
/usr/include/c++/11/type_traits: In instantiation of ‘struct std::is_trivially_move_assignable<dbuf::parser::UnaryExpression>’:
/usr/include/c++/11/type_traits:3211:40:   required from ‘constexpr const bool std::is_trivially_move_assignable_v<dbuf::parser::UnaryExpression>’
/usr/include/c++/11/variant:331:8:   required from ‘constexpr const bool std::__detail::__variant::_Traits<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>::_S_trivial_move_assign’
/usr/include/c++/11/variant:710:11:   required by substitution of ‘template<class ... _Types> using _Move_assign_alias = std::__detail::__variant::_Move_assign_base<std::__detail::__variant::_Traits<_Types>::_S_trivial_move_assign, _Types ...> [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’
/usr/include/c++/11/variant:714:12:   required from ‘struct std::__detail::__variant::_Variant_base<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
/usr/include/c++/11/variant:1343:11:   required from ‘class std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’
src/parser/expression.h:52:14:   required from here
/usr/include/c++/11/type_traits:1331:52: error: static assertion failed: template argument must be a complete class or an unbounded array
/usr/include/c++/11/type_traits:1331:52: note: ‘std::__is_complete_or_unbounded<std::__type_identity<dbuf::parser::UnaryExpression> >((std::__type_identity<dbuf::parser::UnaryExpression>{}, std::__type_identity<dbuf::parser::UnaryExpression>()))’ evaluates to false
In file included from /usr/include/c++/11/bits/stl_algobase.h:64,
                 from /usr/include/c++/11/memory:63,
                 from src/parser/expression.h:3,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/bits/stl_pair.h: In instantiation of ‘constexpr std::pair<typename std::__strip_reference_wrapper<typename std::decay<_Tp>::type>::__type, typename std::__strip_reference_wrapper<typename std::decay<_Tp2>::type>::__type> std::make_pair(_T1&&, _T2&&) [with _T1 = const std::__cxx11::basic_string<char>&; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>&; typename std::__strip_reference_wrapper<typename std::decay<_Tp2>::type>::__type = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>; typename std::decay<_Tp2>::type = std::decay<std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>&>::type; typename std::__strip_reference_wrapper<typename std::decay<_Tp>::type>::__type = std::__cxx11::basic_string<char>; typename std::decay<_Tp>::type = std::decay<const std::__cxx11::basic_string<char>&>::type]’:
src/parser/expression.cc:11:37:   required from here
/usr/include/c++/11/bits/stl_pair.h:572:14: error: no matching function for call to ‘std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >::pair(const std::__cxx11::basic_string<char>&, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>&)’
  572 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/bits/stl_pair.h:452:9: note: candidate: ‘template<class ... _Args1, long unsigned int ..._Indexes1, class ... _Args2, long unsigned int ..._Indexes2> std::pair<_T1, _T2>::pair(std::tuple<_Args1 ...>&, std::tuple<_Args2 ...>&, std::_Index_tuple<_Indexes1 ...>, std::_Index_tuple<_Indexes2 ...>) [with _Args1 = {_Args1 ...}; long unsigned int ..._Indexes1 = {_Indexes1 ...}; _Args2 = {_Args2 ...}; long unsigned int ..._Indexes2 = {_Indexes2 ...}; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  452 |         pair(tuple<_Args1...>&, tuple<_Args2...>&,
      |         ^~~~
/usr/include/c++/11/bits/stl_pair.h:452:9: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:572:14: note:   types ‘std::tuple<_Tps ...>’ and ‘const std::__cxx11::basic_string<char>’ have incompatible cv-qualifiers
  572 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/bits/stl_pair.h:387:9: note: candidate: ‘template<class ... _Args1, class ... _Args2> std::pair<_T1, _T2>::pair(std::piecewise_construct_t, std::tuple<_Args1 ...>, std::tuple<_Args2 ...>) [with _Args1 = {_Args1 ...}; _Args2 = {_Args2 ...}; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  387 |         pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
      |         ^~~~
/usr/include/c++/11/bits/stl_pair.h:387:9: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:572:14: note:   ‘std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>’ is not derived from ‘std::tuple<_Tps ...>’
  572 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/bits/stl_pair.h:381:28: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>, _U2>::value)), std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >::_MoveConstructiblePair<_U1, _U2>() && (! std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>, _U2>::value)), std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >::_ImplicitlyMoveConvertiblePair<_U1, _U2>())), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(std::pair<_U1, _U2>&&) [with _U1 = _U1; _U2 = _U2; typename std::enable_if<(std::_PCC<((! std::is_same<_T1, _U1>::value) || (! std::is_same<_T2, _U2>::value)), _T1, _T2>::_MoveConstructiblePair<_U1, _U2>() && (! std::_PCC<((! std::is_same<_T1, _U1>::value) || (! std::is_same<_T2, _U2>::value)), _T1, _T2>::_ImplicitlyMoveConvertiblePair<_U1, _U2>())), bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  381 |         explicit constexpr pair(pair<_U1, _U2>&& __p)
      |                            ^~~~
/usr/include/c++/11/bits/stl_pair.h:381:28: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:572:14: note:   types ‘std::pair<_T1, _T2>’ and ‘const std::__cxx11::basic_string<char>’ have incompatible cv-qualifiers
  572 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/bits/stl_pair.h:371:19: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>, _U2>::value)), std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >::_MoveConstructiblePair<_U1, _U2>() && std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>, _U2>::value)), std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >::_ImplicitlyMoveConvertiblePair<_U1, _U2>()), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(std::pair<_U1, _U2>&&) [with _U1 = _U1; _U2 = _U2; typename std::enable_if<(std::_PCC<((! std::is_same<_T1, _U1>::value) || (! std::is_same<_T2, _U2>::value)), _T1, _T2>::_MoveConstructiblePair<_U1, _U2>() && std::_PCC<((! std::is_same<_T1, _U1>::value) || (! std::is_same<_T2, _U2>::value)), _T1, _T2>::_ImplicitlyMoveConvertiblePair<_U1, _U2>()), bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  371 |         constexpr pair(pair<_U1, _U2>&& __p)
      |                   ^~~~
/usr/include/c++/11/bits/stl_pair.h:371:19: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:572:14: note:   types ‘std::pair<_T1, _T2>’ and ‘const std::__cxx11::basic_string<char>’ have incompatible cv-qualifiers
  572 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/bits/stl_pair.h:361:28: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(_MoveConstructiblePair<_U1, _U2>() && (! _ImplicitlyMoveConvertiblePair<_U1, _U2>())), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(_U1&&, _U2&&) [with _U1 = _U1; _U2 = _U2; typename std::enable_if<(std::_PCC<true, _T1, _T2>::_MoveConstructiblePair<_U1, _U2>() && (! std::_PCC<true, _T1, _T2>::_ImplicitlyMoveConvertiblePair<_U1, _U2>())), bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  361 |         explicit constexpr pair(_U1&& __x, _U2&& __y)
      |                            ^~~~
/usr/include/c++/11/bits/stl_pair.h:361:28: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:360:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  360 |                          bool>::type=false>
      |                                      ^~~~~
/usr/include/c++/11/bits/stl_pair.h:352:19: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(_MoveConstructiblePair<_U1, _U2>() && _ImplicitlyMoveConvertiblePair<_U1, _U2>()), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(_U1&&, _U2&&) [with _U1 = _U1; _U2 = _U2; typename std::enable_if<(std::_PCC<true, _T1, _T2>::_MoveConstructiblePair<_U1, _U2>() && std::_PCC<true, _T1, _T2>::_ImplicitlyMoveConvertiblePair<_U1, _U2>()), bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  352 |         constexpr pair(_U1&& __x, _U2&& __y)
      |                   ^~~~
/usr/include/c++/11/bits/stl_pair.h:352:19: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:351:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  351 |                          bool>::type=true>
      |                                      ^~~~
/usr/include/c++/11/bits/stl_pair.h:343:17: note: candidate: ‘template<class _U2, typename std::enable_if<_CopyMovePair<false, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, _U2>(), bool>::type <anonymous> > std::pair<_T1, _T2>::pair(const _T1&, _U2&&) [with _U2 = _U2; typename std::enable_if<std::_PCC<true, _T1, _T2>::_CopyMovePair<false, _T1, _U2>(), bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  343 |        explicit pair(const _T1& __x, _U2&& __y)
      |                 ^~~~
/usr/include/c++/11/bits/stl_pair.h:343:17: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:342:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  342 |                          bool>::type=false>
      |                                      ^~~~~
/usr/include/c++/11/bits/stl_pair.h:336:18: note: candidate: ‘template<class _U2, typename std::enable_if<_CopyMovePair<true, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, _U2>(), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const _T1&, _U2&&) [with _U2 = _U2; typename std::enable_if<std::_PCC<true, _T1, _T2>::_CopyMovePair<true, _T1, _U2>(), bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  336 |        constexpr pair(const _T1& __x, _U2&& __y)
      |                  ^~~~
/usr/include/c++/11/bits/stl_pair.h:336:18: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:335:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  335 |                          bool>::type=true>
      |                                      ^~~~
/usr/include/c++/11/bits/stl_pair.h:329:27: note: candidate: ‘template<class _U1, typename std::enable_if<_MoveCopyPair<false, _U1, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >(), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(_U1&&, const _T2&) [with _U1 = _U1; typename std::enable_if<std::_PCC<true, _T1, _T2>::_MoveCopyPair<false, _U1, _T2>(), bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  329 |        explicit constexpr pair(_U1&& __x, const _T2& __y)
      |                           ^~~~
/usr/include/c++/11/bits/stl_pair.h:329:27: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:328:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  328 |                          bool>::type=false>
      |                                      ^~~~~
/usr/include/c++/11/bits/stl_pair.h:322:18: note: candidate: ‘template<class _U1, typename std::enable_if<_MoveCopyPair<true, _U1, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >(), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(_U1&&, const _T2&) [with _U1 = _U1; typename std::enable_if<std::_PCC<true, _T1, _T2>::_MoveCopyPair<true, _U1, _T2>(), bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  322 |        constexpr pair(_U1&& __x, const _T2& __y)
      |                  ^~~~
/usr/include/c++/11/bits/stl_pair.h:322:18: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:321:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  321 |                          bool>::type=true>
      |                                      ^~~~
/usr/include/c++/11/bits/stl_pair.h:309:28: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>, _U2>::value)), std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >::_ConstructiblePair<_U1, _U2>() && (! std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>, _U2>::value)), std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >::_ImplicitlyConvertiblePair<_U1, _U2>())), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const std::pair<_U1, _U2>&) [with _U1 = _U1; _U2 = _U2; typename std::enable_if<(std::_PCC<((! std::is_same<_T1, _U1>::value) || (! std::is_same<_T2, _U2>::value)), _T1, _T2>::_ConstructiblePair<_U1, _U2>() && (! std::_PCC<((! std::is_same<_T1, _U1>::value) || (! std::is_same<_T2, _U2>::value)), _T1, _T2>::_ImplicitlyConvertiblePair<_U1, _U2>())), bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  309 |         explicit constexpr pair(const pair<_U1, _U2>& __p)
      |                            ^~~~
/usr/include/c++/11/bits/stl_pair.h:309:28: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:572:14: note:   ‘const std::__cxx11::basic_string<char>’ is not derived from ‘const std::pair<_T1, _T2>’
  572 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/bits/stl_pair.h:300:19: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>, _U2>::value)), std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >::_ConstructiblePair<_U1, _U2>() && std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>, _U2>::value)), std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >::_ImplicitlyConvertiblePair<_U1, _U2>()), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const std::pair<_U1, _U2>&) [with _U1 = _U1; _U2 = _U2; typename std::enable_if<(std::_PCC<((! std::is_same<_T1, _U1>::value) || (! std::is_same<_T2, _U2>::value)), _T1, _T2>::_ConstructiblePair<_U1, _U2>() && std::_PCC<((! std::is_same<_T1, _U1>::value) || (! std::is_same<_T2, _U2>::value)), _T1, _T2>::_ImplicitlyConvertiblePair<_U1, _U2>()), bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  300 |         constexpr pair(const pair<_U1, _U2>& __p)
      |                   ^~~~
/usr/include/c++/11/bits/stl_pair.h:300:19: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:572:14: note:   ‘const std::__cxx11::basic_string<char>’ is not derived from ‘const std::pair<_T1, _T2>’
  572 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/bits/stl_pair.h:276:26: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(_ConstructiblePair<_U1, _U2>() && (! _ImplicitlyConvertiblePair<_U1, _U2>())), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const _T1&, const _T2&) [with _U1 = _U1; _U2 = _U2; typename std::enable_if<(std::_PCC<true, _T1, _T2>::_ConstructiblePair<_U1, _U2>() && (! std::_PCC<true, _T1, _T2>::_ImplicitlyConvertiblePair<_U1, _U2>())), bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  276 |       explicit constexpr pair(const _T1& __a, const _T2& __b)
      |                          ^~~~
/usr/include/c++/11/bits/stl_pair.h:276:26: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:275:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  275 |                          bool>::type=false>
      |                                      ^~~~~
/usr/include/c++/11/bits/stl_pair.h:266:17: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(_ConstructiblePair<_U1, _U2>() && _ImplicitlyConvertiblePair<_U1, _U2>()), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const _T1&, const _T2&) [with _U1 = _U1; _U2 = _U2; typename std::enable_if<(std::_PCC<true, _T1, _T2>::_ConstructiblePair<_U1, _U2>() && std::_PCC<true, _T1, _T2>::_ImplicitlyConvertiblePair<_U1, _U2>()), bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  266 |       constexpr pair(const _T1& __a, const _T2& __b)
      |                 ^~~~
/usr/include/c++/11/bits/stl_pair.h:266:17: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:265:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  265 |                          bool>::type=true>
      |                                      ^~~~
/usr/include/c++/11/bits/stl_pair.h:245:26: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<std::__and_<std::is_default_constructible<_U1>, std::is_default_constructible<_Dp>, std::__not_<std::__and_<std::__is_implicitly_default_constructible<_U1>, std::__is_implicitly_default_constructible<_U2> > > >::value, bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair() [with _U1 = _U1; _U2 = _U2; typename std::enable_if<std::__and_<std::is_default_constructible<_U1>, std::is_default_constructible<_U2>, std::__not_<std::__and_<std::__is_implicitly_default_constructible<_U1>, std::__is_implicitly_default_constructible<_U2> > > >::value, bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  245 |       explicit constexpr pair()
      |                          ^~~~
/usr/include/c++/11/bits/stl_pair.h:245:26: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:572:14: note:   candidate expects 0 arguments, 2 provided
  572 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/11/bits/stl_pair.h:232:26: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<std::__and_<std::__is_implicitly_default_constructible<_U1>, std::__is_implicitly_default_constructible<_U2> >::value, bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair() [with _U1 = _U1; _U2 = _U2; typename std::enable_if<std::__and_<std::__is_implicitly_default_constructible<_U1>, std::__is_implicitly_default_constructible<_U2> >::value, bool>::type <anonymous> = <anonymous>; _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  232 |       _GLIBCXX_CONSTEXPR pair()
      |                          ^~~~
/usr/include/c++/11/bits/stl_pair.h:232:26: note:   template argument deduction/substitution failed:
/usr/include/c++/11/bits/stl_pair.h:572:14: note:   candidate expects 0 arguments, 2 provided
  572 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/x86_64-linux-gnu/c++/11/bits/c++allocator.h:33,
                 from /usr/include/c++/11/bits/allocator.h:46,
                 from /usr/include/c++/11/memory:64,
                 from src/parser/expression.h:3,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/ext/new_allocator.h: In instantiation of ‘void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >; _Args = {std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >}; _Tp = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >]’:
/usr/include/c++/11/bits/alloc_traits.h:516:17:   required from ‘static void std::allocator_traits<std::allocator<_Tp1> >::construct(std::allocator_traits<std::allocator<_Tp1> >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >; _Args = {std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >}; _Tp = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >; std::allocator_traits<std::allocator<_Tp1> >::allocator_type = std::allocator<std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> > >]’
/usr/include/c++/11/bits/vector.tcc:115:30:   required from ‘std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >}; _Tp = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >; _Alloc = std::allocator<std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> > >; std::vector<_Tp, _Alloc>::reference = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >&]’
/usr/include/c++/11/bits/stl_vector.h:1204:21:   required from ‘void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >; _Alloc = std::allocator<std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> > >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >]’
src/parser/expression.cc:11:22:   required from here
/usr/include/c++/11/ext/new_allocator.h:162:11: error: use of deleted function ‘constexpr std::pair<_T1, _T2>::pair(std::pair<_T1, _T2>&&) [with _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
  162 |         { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
      |           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/11/bits/stl_algobase.h:64,
                 from /usr/include/c++/11/memory:63,
                 from src/parser/expression.h:3,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/bits/stl_pair.h:315:17: note: ‘constexpr std::pair<_T1, _T2>::pair(std::pair<_T1, _T2>&&) [with _T1 = std::__cxx11::basic_string<char>; _T2 = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’ is implicitly deleted because the default definition would be ill-formed:
  315 |       constexpr pair(pair&&) = default;         ///< Move constructor
      |                 ^~~~
/usr/include/c++/11/bits/stl_pair.h:315:17: error: use of deleted function ‘std::variant<_Types>::variant(std::variant<_Types>&&) [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’
In file included from src/parser/expression.h:6,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/variant:1413:7: note: ‘std::variant<_Types>::variant(std::variant<_Types>&&) [with _Types = {dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess}]’ is implicitly deleted because the default definition would be ill-formed:
 1413 |       variant(variant&&) = default;
      |       ^~~~~~~
/usr/include/c++/11/variant:1413:7: error: use of deleted function ‘constexpr std::_Enable_copy_move<false, false, false, false, _Tag>::_Enable_copy_move(std::_Enable_copy_move<false, false, false, false, _Tag>&&) [with _Tag = std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess>]’
In file included from /usr/include/c++/11/variant:38,
                 from src/parser/expression.h:6,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/bits/enable_special_members.h:305:15: note: declared here
  305 |     constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = delete;
      |               ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/11/memory:66,
                 from src/parser/expression.h:3,
                 from src/parser/expression.cc:1:
/usr/include/c++/11/bits/stl_uninitialized.h: In instantiation of ‘_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = std::move_iterator<std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >*>; _ForwardIterator = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >*]’:
/usr/include/c++/11/bits/stl_uninitialized.h:333:37:   required from ‘_ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, std::allocator<_Tp>&) [with _InputIterator = std::move_iterator<std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >*>; _ForwardIterator = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >*; _Tp = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >]’
/usr/include/c++/11/bits/stl_uninitialized.h:355:2:   required from ‘_ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&) [with _InputIterator = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >*; _ForwardIterator = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >*; _Allocator = std::allocator<std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> > >]’
/usr/include/c++/11/bits/vector.tcc:474:3:   required from ‘void std::vector<_Tp, _Alloc>::_M_realloc_insert(std::vector<_Tp, _Alloc>::iterator, _Args&& ...) [with _Args = {std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >}; _Tp = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >; _Alloc = std::allocator<std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> > >; std::vector<_Tp, _Alloc>::iterator = std::vector<std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> > >::iterator]’
/usr/include/c++/11/bits/vector.tcc:121:21:   required from ‘std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >}; _Tp = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >; _Alloc = std::allocator<std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> > >; std::vector<_Tp, _Alloc>::reference = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >&]’
/usr/include/c++/11/bits/stl_vector.h:1204:21:   required from ‘void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >; _Alloc = std::allocator<std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> > >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::__cxx11::basic_string<char>, std::variant<dbuf::parser::BinaryExpression, dbuf::parser::UnaryExpression, dbuf::parser::TypeExpression, std::variant<dbuf::parser::ScalarValue<bool>, dbuf::parser::ScalarValue<double>, dbuf::parser::ScalarValue<long long int>, dbuf::parser::ScalarValue<unsigned int>, dbuf::parser::ScalarValue<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, dbuf::parser::ConstructedValue>, dbuf::parser::VarAccess> >]’
src/parser/expression.cc:11:22:   required from here
/usr/include/c++/11/bits/stl_uninitialized.h:138:72: error: static assertion failed: result type must be constructible from value type of input range
  138 |       static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,
      |                                                                        ^~~~~
/usr/include/c++/11/bits/stl_uninitialized.h:138:72: note: ‘std::integral_constant<bool, false>::value’ evaluates to false
